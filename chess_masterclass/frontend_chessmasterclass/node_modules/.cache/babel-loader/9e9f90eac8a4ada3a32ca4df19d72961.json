{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Chess = exports.validateFen = exports.SQUARES = exports.DEFAULT_POSITION = exports.KING = exports.QUEEN = exports.ROOK = exports.BISHOP = exports.KNIGHT = exports.PAWN = exports.BLACK = exports.WHITE = void 0;\n/*\n * Copyright (c) 2022, Jeff Hlywa (jhlywa@gmail.com)\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *\n *----------------------------------------------------------------------------*/\n\nexports.WHITE = 'w';\nexports.BLACK = 'b';\nexports.PAWN = 'p';\nexports.KNIGHT = 'n';\nexports.BISHOP = 'b';\nexports.ROOK = 'r';\nexports.QUEEN = 'q';\nexports.KING = 'k';\nexports.DEFAULT_POSITION = 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1';\nconst EMPTY = -1;\nconst FLAGS = {\n  NORMAL: 'n',\n  CAPTURE: 'c',\n  BIG_PAWN: 'b',\n  EP_CAPTURE: 'e',\n  PROMOTION: 'p',\n  KSIDE_CASTLE: 'k',\n  QSIDE_CASTLE: 'q'\n}; // prettier-ignore\n\nexports.SQUARES = ['a8', 'b8', 'c8', 'd8', 'e8', 'f8', 'g8', 'h8', 'a7', 'b7', 'c7', 'd7', 'e7', 'f7', 'g7', 'h7', 'a6', 'b6', 'c6', 'd6', 'e6', 'f6', 'g6', 'h6', 'a5', 'b5', 'c5', 'd5', 'e5', 'f5', 'g5', 'h5', 'a4', 'b4', 'c4', 'd4', 'e4', 'f4', 'g4', 'h4', 'a3', 'b3', 'c3', 'd3', 'e3', 'f3', 'g3', 'h3', 'a2', 'b2', 'c2', 'd2', 'e2', 'f2', 'g2', 'h2', 'a1', 'b1', 'c1', 'd1', 'e1', 'f1', 'g1', 'h1'];\nconst BITS = {\n  NORMAL: 1,\n  CAPTURE: 2,\n  BIG_PAWN: 4,\n  EP_CAPTURE: 8,\n  PROMOTION: 16,\n  KSIDE_CASTLE: 32,\n  QSIDE_CASTLE: 64\n}; // NOTES ABOUT 0x88 MOVE GENERATION ALGORITHM\n// ----------------------------------------------------------------------------\n// From https://github.com/jhlywa/chess.js/issues/230\n//\n// A lot of people are confused when they first see the internal representation\n// of chess.js. It uses the 0x88 Move Generation Algorithm which internally\n// stores the board as an 8x16 array. This is purely for efficiency but has a\n// couple of interesting benefits:\n//\n// 1. 0x88 offers a very inexpensive \"off the board\" check. Bitwise AND (&) any\n//    square with 0x88, if the result is non-zero then the square is off the\n//    board. For example, assuming a knight square A8 (0 in 0x88 notation),\n//    there are 8 possible directions in which the knight can move. These\n//    directions are relative to the 8x16 board and are stored in the\n//    PIECE_OFFSETS map. One possible move is A8 - 18 (up one square, and two\n//    squares to the left - which is off the board). 0 - 18 = -18 & 0x88 = 0x88\n//    (because of two-complement representation of -18). The non-zero result\n//    means the square is off the board and the move is illegal. Take the\n//    opposite move (from A8 to C7), 0 + 18 = 18 & 0x88 = 0. A result of zero\n//    means the square is on the board.\n//\n// 2. The relative distance (or difference) between two squares on a 8x16 board\n//    is unique and can be used to inexpensively determine if a piece on a\n//    square can attack any other arbitrary square. For example, let's see if a\n//    pawn on E7 can attack E2. The difference between E7 (20) - E2 (100) is\n//    -80. We add 119 to make the ATTACKS array index non-negative (because the\n//    worst case difference is A8 - H1 = -119). The ATTACKS array contains a\n//    bitmask of pieces that can attack from that distance and direction.\n//    ATTACKS[-80 + 119=39] gives us 24 or 0b11000 in binary. Look at the\n//    PIECE_MASKS map to determine the mask for a given piece type. In our pawn\n//    example, we would check to see if 24 & 0x1 is non-zero, which it is\n//    not. So, naturally, a pawn on E7 can't attack a piece on E2. However, a\n//    rook can since 24 & 0x8 is non-zero. The only thing left to check is that\n//    there are no blocking pieces between E7 and E2. That's where the RAYS\n//    array comes in. It provides an offset (in this case 16) to add to E7 (20)\n//    to check for blocking pieces. E7 (20) + 16 = E6 (36) + 16 = E5 (52) etc.\n// prettier-ignore\n\nconst Ox88 = {\n  a8: 0,\n  b8: 1,\n  c8: 2,\n  d8: 3,\n  e8: 4,\n  f8: 5,\n  g8: 6,\n  h8: 7,\n  a7: 16,\n  b7: 17,\n  c7: 18,\n  d7: 19,\n  e7: 20,\n  f7: 21,\n  g7: 22,\n  h7: 23,\n  a6: 32,\n  b6: 33,\n  c6: 34,\n  d6: 35,\n  e6: 36,\n  f6: 37,\n  g6: 38,\n  h6: 39,\n  a5: 48,\n  b5: 49,\n  c5: 50,\n  d5: 51,\n  e5: 52,\n  f5: 53,\n  g5: 54,\n  h5: 55,\n  a4: 64,\n  b4: 65,\n  c4: 66,\n  d4: 67,\n  e4: 68,\n  f4: 69,\n  g4: 70,\n  h4: 71,\n  a3: 80,\n  b3: 81,\n  c3: 82,\n  d3: 83,\n  e3: 84,\n  f3: 85,\n  g3: 86,\n  h3: 87,\n  a2: 96,\n  b2: 97,\n  c2: 98,\n  d2: 99,\n  e2: 100,\n  f2: 101,\n  g2: 102,\n  h2: 103,\n  a1: 112,\n  b1: 113,\n  c1: 114,\n  d1: 115,\n  e1: 116,\n  f1: 117,\n  g1: 118,\n  h1: 119\n};\nconst PAWN_OFFSETS = {\n  b: [16, 32, 17, 15],\n  w: [-16, -32, -17, -15]\n};\nconst PIECE_OFFSETS = {\n  n: [-18, -33, -31, -14, 18, 33, 31, 14],\n  b: [-17, -15, 17, 15],\n  r: [-16, 1, 16, -1],\n  q: [-17, -16, -15, 1, 17, 16, 15, -1],\n  k: [-17, -16, -15, 1, 17, 16, 15, -1]\n}; // prettier-ignore\n\nconst ATTACKS = [20, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 20, 0, 0, 20, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 20, 0, 0, 0, 0, 20, 0, 0, 0, 0, 24, 0, 0, 0, 0, 20, 0, 0, 0, 0, 0, 0, 20, 0, 0, 0, 24, 0, 0, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 20, 0, 0, 24, 0, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20, 2, 24, 2, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 53, 56, 53, 2, 0, 0, 0, 0, 0, 0, 24, 24, 24, 24, 24, 24, 56, 0, 56, 24, 24, 24, 24, 24, 24, 0, 0, 0, 0, 0, 0, 2, 53, 56, 53, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20, 2, 24, 2, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20, 0, 0, 24, 0, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 20, 0, 0, 0, 24, 0, 0, 0, 20, 0, 0, 0, 0, 0, 0, 20, 0, 0, 0, 0, 24, 0, 0, 0, 0, 20, 0, 0, 0, 0, 20, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 20, 0, 0, 20, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 20]; // prettier-ignore\n\nconst RAYS = [17, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 15, 0, 0, 17, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 15, 0, 0, 0, 0, 17, 0, 0, 0, 0, 16, 0, 0, 0, 0, 15, 0, 0, 0, 0, 0, 0, 17, 0, 0, 0, 16, 0, 0, 0, 15, 0, 0, 0, 0, 0, 0, 0, 0, 17, 0, 0, 16, 0, 0, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 17, 0, 16, 0, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 17, 16, 15, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, -1, -1, -1, -1, -1, -1, -1, 0, 0, 0, 0, 0, 0, 0, -15, -16, -17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -15, 0, -16, 0, -17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -15, 0, 0, -16, 0, 0, -17, 0, 0, 0, 0, 0, 0, 0, 0, -15, 0, 0, 0, -16, 0, 0, 0, -17, 0, 0, 0, 0, 0, 0, -15, 0, 0, 0, 0, -16, 0, 0, 0, 0, -17, 0, 0, 0, 0, -15, 0, 0, 0, 0, 0, -16, 0, 0, 0, 0, 0, -17, 0, 0, -15, 0, 0, 0, 0, 0, 0, -16, 0, 0, 0, 0, 0, 0, -17];\nconst PIECE_MASKS = {\n  p: 0x1,\n  n: 0x2,\n  b: 0x4,\n  r: 0x8,\n  q: 0x10,\n  k: 0x20\n};\nconst SYMBOLS = 'pnbrqkPNBRQK';\nconst PROMOTIONS = [exports.KNIGHT, exports.BISHOP, exports.ROOK, exports.QUEEN];\nconst RANK_1 = 7;\nconst RANK_2 = 6; // const RANK_3 = 5\n// const RANK_4 = 4\n// const RANK_5 = 3\n// const RANK_6 = 2\n\nconst RANK_7 = 1;\nconst RANK_8 = 0;\nconst ROOKS = {\n  w: [{\n    square: Ox88.a1,\n    flag: BITS.QSIDE_CASTLE\n  }, {\n    square: Ox88.h1,\n    flag: BITS.KSIDE_CASTLE\n  }],\n  b: [{\n    square: Ox88.a8,\n    flag: BITS.QSIDE_CASTLE\n  }, {\n    square: Ox88.h8,\n    flag: BITS.KSIDE_CASTLE\n  }]\n};\nconst SECOND_RANK = {\n  b: RANK_7,\n  w: RANK_2\n};\nconst TERMINATION_MARKERS = ['1-0', '0-1', '1/2-1/2', '*'];\n/**\n * Extracts the zero-based rank of an 0x88 square.\n */\n\nfunction rank(square) {\n  return square >> 4;\n}\n/**\n * Extracts the zero-based file of an 0x88 square.\n */\n\n\nfunction file(square) {\n  return square & 0xf;\n}\n\nfunction isDigit(c) {\n  return '0123456789'.indexOf(c) !== -1;\n}\n/**\n * Converts a 0x88 square to algebraic notation.\n */\n\n\nfunction algebraic(square) {\n  const f = file(square);\n  const r = rank(square);\n  return 'abcdefgh'.substring(f, f + 1) + '87654321'.substring(r, r + 1);\n}\n\nfunction swapColor(color) {\n  return color === exports.WHITE ? exports.BLACK : exports.WHITE;\n}\n/* TODO: this needs a bit of work - it validates structure but completely\n * ignores content (e.g. doesn't verify that each side has a king) ... we should\n * rewrite this, and ditch the silly error_number field while we're at it */\n\n\nfunction validateFen(fen) {\n  const errors = [];\n  errors[0] = 'No errors.';\n  errors[1] = 'FEN string must contain six space-delimited fields.';\n  errors[2] = '6th field (move number) must be a positive integer.';\n  errors[3] = '5th field (half move counter) must be a non-negative integer.';\n  errors[4] = '4th field (en-passant square) is invalid.';\n  errors[5] = '3rd field (castling availability) is invalid.';\n  errors[6] = '2nd field (side to move) is invalid.';\n  errors[7] = \"1st field (piece positions) does not contain 8 '/'-delimited rows.\";\n  errors[8] = '1st field (piece positions) is invalid [consecutive numbers].';\n  errors[9] = '1st field (piece positions) is invalid [invalid piece].';\n  errors[10] = '1st field (piece positions) is invalid [row too large].';\n  errors[11] = 'Illegal en-passant square';\n  /* 1st criterion: 6 space-seperated fields? */\n\n  const tokens = fen.split(/\\s+/);\n\n  if (tokens.length !== 6) {\n    return {\n      valid: false,\n      errorNumber: 1,\n      error: errors[1]\n    };\n  }\n  /* 2nd criterion: move number field is a integer value > 0? */\n\n\n  const moveNumber = parseInt(tokens[5], 10);\n\n  if (isNaN(moveNumber) || moveNumber <= 0) {\n    return {\n      valid: false,\n      errorNumber: 2,\n      error: errors[2]\n    };\n  }\n  /* 3rd criterion: half move counter is an integer >= 0? */\n\n\n  const halfMoves = parseInt(tokens[4], 10);\n\n  if (isNaN(halfMoves) || halfMoves < 0) {\n    return {\n      valid: false,\n      errorNumber: 3,\n      error: errors[3]\n    };\n  }\n  /* 4th criterion: 4th field is a valid e.p.-string? */\n\n\n  if (!/^(-|[abcdefgh][36])$/.test(tokens[3])) {\n    return {\n      valid: false,\n      errorNumber: 4,\n      error: errors[4]\n    };\n  }\n  /* 5th criterion: 3th field is a valid castle-string? */\n\n\n  if (!/^(KQ?k?q?|Qk?q?|kq?|q|-)$/.test(tokens[2])) {\n    return {\n      valid: false,\n      errorNumber: 5,\n      error: errors[5]\n    };\n  }\n  /* 6th criterion: 2nd field is \"w\" (white) or \"b\" (black)? */\n\n\n  if (!/^(w|b)$/.test(tokens[1])) {\n    return {\n      valid: false,\n      errorNumber: 6,\n      error: errors[6]\n    };\n  }\n  /* 7th criterion: 1st field contains 8 rows? */\n\n\n  const rows = tokens[0].split('/');\n\n  if (rows.length !== 8) {\n    return {\n      valid: false,\n      errorNumber: 7,\n      error: errors[7]\n    };\n  }\n  /* 8th criterion: every row is valid? */\n\n\n  for (let i = 0; i < rows.length; i++) {\n    /* check for right sum of fields AND not two numbers in succession */\n    let sumFields = 0;\n    let previousWasNumber = false;\n\n    for (let k = 0; k < rows[i].length; k++) {\n      if (isDigit(rows[i][k])) {\n        if (previousWasNumber) {\n          return {\n            valid: false,\n            errorNumber: 8,\n            error: errors[8]\n          };\n        }\n\n        sumFields += parseInt(rows[i][k], 10);\n        previousWasNumber = true;\n      } else {\n        if (!/^[prnbqkPRNBQK]$/.test(rows[i][k])) {\n          return {\n            valid: false,\n            errorNumber: 9,\n            error: errors[9]\n          };\n        }\n\n        sumFields += 1;\n        previousWasNumber = false;\n      }\n    }\n\n    if (sumFields !== 8) {\n      return {\n        valid: false,\n        errorNumber: 10,\n        error: errors[10]\n      };\n    }\n  }\n\n  if (tokens[3][1] == '3' && tokens[1] == 'w' || tokens[3][1] == '6' && tokens[1] == 'b') {\n    return {\n      valid: false,\n      errorNumber: 11,\n      error: errors[11]\n    };\n  }\n  /* everything's okay! */\n\n\n  return {\n    valid: true,\n    errorNumber: 0,\n    error: errors[0]\n  };\n}\n\nexports.validateFen = validateFen;\n/* this function is used to uniquely identify ambiguous moves */\n\nfunction getDisambiguator(move, moves) {\n  const from = move.from;\n  const to = move.to;\n  const piece = move.piece;\n  let ambiguities = 0;\n  let sameRank = 0;\n  let sameFile = 0;\n\n  for (let i = 0, len = moves.length; i < len; i++) {\n    const ambigFrom = moves[i].from;\n    const ambigTo = moves[i].to;\n    const ambigPiece = moves[i].piece;\n    /* if a move of the same piece type ends on the same to square, we'll\n     * need to add a disambiguator to the algebraic notation\n     */\n\n    if (piece === ambigPiece && from !== ambigFrom && to === ambigTo) {\n      ambiguities++;\n\n      if (rank(from) === rank(ambigFrom)) {\n        sameRank++;\n      }\n\n      if (file(from) === file(ambigFrom)) {\n        sameFile++;\n      }\n    }\n  }\n\n  if (ambiguities > 0) {\n    /* if there exists a similar moving piece on the same rank and file\n       as the move in question, use the square as the disambiguator\n    */\n    if (sameRank > 0 && sameFile > 0) {\n      return algebraic(from);\n    } else if (sameFile > 0) {\n      /* if the moving piece rests on the same file, use the rank symbol\n         as the disambiguator\n       */\n      return algebraic(from).charAt(1);\n    } else {\n      /* else use the file symbol */\n      return algebraic(from).charAt(0);\n    }\n  }\n\n  return '';\n}\n\nfunction addMove(moves, color, from, to, piece) {\n  let captured = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : undefined;\n  let flags = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : BITS.NORMAL;\n  const r = rank(to);\n\n  if (piece === exports.PAWN && (r === RANK_1 || r === RANK_8)) {\n    for (let i = 0; i < PROMOTIONS.length; i++) {\n      const promotion = PROMOTIONS[i];\n      moves.push({\n        color,\n        from,\n        to,\n        piece,\n        captured,\n        promotion,\n        flags: flags | BITS.PROMOTION\n      });\n    }\n  } else {\n    moves.push({\n      color,\n      from,\n      to,\n      piece,\n      captured,\n      promotion: undefined,\n      flags\n    });\n  }\n}\n\nfunction inferPieceType(san) {\n  let pieceType = san.charAt(0);\n\n  if (pieceType >= 'a' && pieceType <= 'h') {\n    const matches = san.match(/[a-h]\\d.*[a-h]\\d/);\n\n    if (matches) {\n      return undefined;\n    }\n\n    return exports.PAWN;\n  }\n\n  pieceType = pieceType.toLowerCase();\n\n  if (pieceType === 'o') {\n    return exports.KING;\n  }\n\n  return pieceType;\n} // parses all of the decorators out of a SAN string\n\n\nfunction strippedSan(move) {\n  return move.replace(/=/, '').replace(/[+#]?[?!]*$/, '');\n}\n\nclass Chess {\n  constructor() {\n    let fen = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : exports.DEFAULT_POSITION;\n    this._board = new Array(128);\n    this._turn = exports.WHITE;\n    this._header = {};\n    this._kings = {\n      w: EMPTY,\n      b: EMPTY\n    };\n    this._epSquare = -1;\n    this._halfMoves = 0;\n    this._moveNumber = 0;\n    this._history = [];\n    this._comments = {};\n    this._castling = {\n      w: 0,\n      b: 0\n    };\n    this.load(fen);\n  }\n\n  clear() {\n    let keepHeaders = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    this._board = new Array(128);\n    this._kings = {\n      w: EMPTY,\n      b: EMPTY\n    };\n    this._turn = exports.WHITE;\n    this._castling = {\n      w: 0,\n      b: 0\n    };\n    this._epSquare = EMPTY;\n    this._halfMoves = 0;\n    this._moveNumber = 1;\n    this._history = [];\n    this._comments = {};\n    this._header = keepHeaders ? this._header : {};\n\n    this._updateSetup(this.fen());\n  }\n\n  load(fen) {\n    let keepHeaders = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const tokens = fen.split(/\\s+/);\n    const position = tokens[0];\n    let square = 0;\n\n    if (!validateFen(fen).valid) {\n      return false;\n    }\n\n    this.clear(keepHeaders);\n\n    for (let i = 0; i < position.length; i++) {\n      const piece = position.charAt(i);\n\n      if (piece === '/') {\n        square += 8;\n      } else if (isDigit(piece)) {\n        square += parseInt(piece, 10);\n      } else {\n        const color = piece < 'a' ? exports.WHITE : exports.BLACK;\n        this.put({\n          type: piece.toLowerCase(),\n          color\n        }, algebraic(square));\n        square++;\n      }\n    }\n\n    this._turn = tokens[1];\n\n    if (tokens[2].indexOf('K') > -1) {\n      this._castling.w |= BITS.KSIDE_CASTLE;\n    }\n\n    if (tokens[2].indexOf('Q') > -1) {\n      this._castling.w |= BITS.QSIDE_CASTLE;\n    }\n\n    if (tokens[2].indexOf('k') > -1) {\n      this._castling.b |= BITS.KSIDE_CASTLE;\n    }\n\n    if (tokens[2].indexOf('q') > -1) {\n      this._castling.b |= BITS.QSIDE_CASTLE;\n    }\n\n    this._epSquare = tokens[3] === '-' ? EMPTY : Ox88[tokens[3]];\n    this._halfMoves = parseInt(tokens[4], 10);\n    this._moveNumber = parseInt(tokens[5], 10);\n\n    this._updateSetup(this.fen());\n\n    return true;\n  }\n\n  fen() {\n    let empty = 0;\n    let fen = '';\n\n    for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n      if (this._board[i]) {\n        if (empty > 0) {\n          fen += empty;\n          empty = 0;\n        }\n\n        const {\n          color,\n          type: piece\n        } = this._board[i];\n        fen += color === exports.WHITE ? piece.toUpperCase() : piece.toLowerCase();\n      } else {\n        empty++;\n      }\n\n      if (i + 1 & 0x88) {\n        if (empty > 0) {\n          fen += empty;\n        }\n\n        if (i !== Ox88.h1) {\n          fen += '/';\n        }\n\n        empty = 0;\n        i += 8;\n      }\n    }\n\n    let cflags = '';\n\n    if (this._castling[exports.WHITE] & BITS.KSIDE_CASTLE) {\n      cflags += 'K';\n    }\n\n    if (this._castling[exports.WHITE] & BITS.QSIDE_CASTLE) {\n      cflags += 'Q';\n    }\n\n    if (this._castling[exports.BLACK] & BITS.KSIDE_CASTLE) {\n      cflags += 'k';\n    }\n\n    if (this._castling[exports.BLACK] & BITS.QSIDE_CASTLE) {\n      cflags += 'q';\n    }\n    /* do we have an empty castling flag? */\n\n\n    cflags = cflags || '-';\n    const epflags = this._epSquare === EMPTY ? '-' : algebraic(this._epSquare);\n    return [fen, this._turn, cflags, epflags, this._halfMoves, this._moveNumber].join(' ');\n  }\n  /* Called when the initial board setup is changed with put() or remove().\n   * modifies the SetUp and FEN properties of the header object.  if the FEN\n   * is equal to the default position, the SetUp and FEN are deleted the setup\n   * is only updated if history.length is zero, ie moves haven't been  made.\n   */\n\n\n  _updateSetup(fen) {\n    if (this._history.length > 0) return;\n\n    if (fen !== exports.DEFAULT_POSITION) {\n      this._header['SetUp'] = '1';\n      this._header['FEN'] = fen;\n    } else {\n      delete this._header['SetUp'];\n      delete this._header['FEN'];\n    }\n  }\n\n  reset() {\n    this.load(exports.DEFAULT_POSITION);\n  }\n\n  get(square) {\n    return this._board[Ox88[square]] || false;\n  }\n\n  put(_ref, square) {\n    let {\n      type,\n      color\n    } = _ref;\n\n    /* check for piece */\n    if (SYMBOLS.indexOf(type.toLowerCase()) === -1) {\n      return false;\n    }\n    /* check for valid square */\n\n\n    if (!(square in Ox88)) {\n      return false;\n    }\n\n    const sq = Ox88[square];\n    /* don't let the user place more than one king */\n\n    if (type == exports.KING && !(this._kings[color] == EMPTY || this._kings[color] == sq)) {\n      return false;\n    }\n\n    this._board[sq] = {\n      type: type,\n      color: color\n    };\n\n    if (type === exports.KING) {\n      this._kings[color] = sq;\n    }\n\n    this._updateSetup(this.fen());\n\n    return true;\n  }\n\n  remove(square) {\n    const piece = this.get(square);\n    delete this._board[Ox88[square]];\n\n    if (piece && piece.type === exports.KING) {\n      this._kings[piece.color] = EMPTY;\n    }\n\n    this._updateSetup(this.fen());\n\n    return piece;\n  }\n\n  _attacked(color, square) {\n    for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n      /* did we run off the end of the board */\n      if (i & 0x88) {\n        i += 7;\n        continue;\n      }\n      /* if empty square or wrong color */\n\n\n      if (this._board[i] === undefined || this._board[i].color !== color) {\n        continue;\n      }\n\n      const piece = this._board[i];\n      const difference = i - square;\n      const index = difference + 119;\n\n      if (ATTACKS[index] & PIECE_MASKS[piece.type]) {\n        if (piece.type === exports.PAWN) {\n          if (difference > 0) {\n            if (piece.color === exports.WHITE) return true;\n          } else {\n            if (piece.color === exports.BLACK) return true;\n          }\n\n          continue;\n        }\n        /* if the piece is a knight or a king */\n\n\n        if (piece.type === 'n' || piece.type === 'k') return true;\n        const offset = RAYS[index];\n        let j = i + offset;\n        let blocked = false;\n\n        while (j !== square) {\n          if (this._board[j] != null) {\n            blocked = true;\n            break;\n          }\n\n          j += offset;\n        }\n\n        if (!blocked) return true;\n      }\n    }\n\n    return false;\n  }\n\n  _isKingAttacked(color) {\n    return this._attacked(swapColor(color), this._kings[color]);\n  }\n\n  isCheck() {\n    return this._isKingAttacked(this._turn);\n  }\n\n  inCheck() {\n    return this.isCheck();\n  }\n\n  isCheckmate() {\n    return this.isCheck() && this._moves().length === 0;\n  }\n\n  isStalemate() {\n    return !this.isCheck() && this._moves().length === 0;\n  }\n\n  isInsufficientMaterial() {\n    // k.b. vs k.b. (of opposite colors) with mate in 1:\n    // 8/8/8/8/1b6/8/B1k5/K7 b - - 0 1\n    //\n    // k.b. vs k.n. with mate in 1:\n    // 8/8/8/8/1n6/8/B7/K1k5 b - - 2 1\n    const pieces = {\n      b: 0,\n      n: 0,\n      r: 0,\n      q: 0,\n      k: 0,\n      p: 0\n    };\n    const bishops = [];\n    let numPieces = 0;\n    let squareColor = 0;\n\n    for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n      squareColor = (squareColor + 1) % 2;\n\n      if (i & 0x88) {\n        i += 7;\n        continue;\n      }\n\n      const piece = this._board[i];\n\n      if (piece) {\n        pieces[piece.type] = piece.type in pieces ? pieces[piece.type] + 1 : 1;\n\n        if (piece.type === exports.BISHOP) {\n          bishops.push(squareColor);\n        }\n\n        numPieces++;\n      }\n    } // k vs. k\n\n\n    if (numPieces === 2) {\n      return true;\n    } else if ( // k vs. kn .... or .... k vs. kb\n    numPieces === 3 && (pieces[exports.BISHOP] === 1 || pieces[exports.KNIGHT] === 1)) {\n      return true;\n    } else if (numPieces === pieces[exports.BISHOP] + 2) {\n      // kb vs. kb where any number of bishops are all on the same color\n      let sum = 0;\n      const len = bishops.length;\n\n      for (let i = 0; i < len; i++) {\n        sum += bishops[i];\n      }\n\n      if (sum === 0 || sum === len) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  isThreefoldRepetition() {\n    /* TODO: while this function is fine for casual use, a better\n      * implementation would use a Zobrist key (instead of FEN). the\n      * Zobrist key would be maintained in the make_move/undo_move\n      functions,\n      * avoiding the costly that we do below.\n      */\n    const moves = [];\n    const positions = {};\n    let repetition = false;\n\n    while (true) {\n      const move = this._undoMove();\n\n      if (!move) break;\n      moves.push(move);\n    }\n\n    while (true) {\n      /* remove the last two fields in the FEN string, they're not needed\n       * when checking for draw by rep */\n      const fen = this.fen().split(' ').slice(0, 4).join(' ');\n      /* has the position occurred three or move times */\n\n      positions[fen] = fen in positions ? positions[fen] + 1 : 1;\n\n      if (positions[fen] >= 3) {\n        repetition = true;\n      }\n\n      const move = moves.pop();\n\n      if (!move) {\n        break;\n      } else {\n        this._makeMove(move);\n      }\n    }\n\n    return repetition;\n  }\n\n  isDraw() {\n    return this._halfMoves >= 100 || // 50 moves per side = 100 half moves\n    this.isStalemate() || this.isInsufficientMaterial() || this.isThreefoldRepetition();\n  }\n\n  isGameOver() {\n    return this.isCheckmate() || this.isStalemate() || this.isDraw();\n  }\n\n  moves() {\n    let {\n      verbose = false,\n      square = undefined\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    const moves = this._moves({\n      square\n    });\n\n    if (verbose) {\n      return moves.map(move => this._makePretty(move));\n    } else {\n      return moves.map(move => this._moveToSan(move, moves));\n    }\n  }\n\n  _moves() {\n    let {\n      legal = true,\n      piece = undefined,\n      square = undefined\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    var _a;\n\n    const forSquare = square ? square.toLowerCase() : undefined;\n    const forPiece = piece === null || piece === void 0 ? void 0 : piece.toLowerCase();\n    const moves = [];\n    const us = this._turn;\n    const them = swapColor(us);\n    let firstSquare = Ox88.a8;\n    let lastSquare = Ox88.h1;\n    let singleSquare = false;\n    /* are we generating moves for a single square? */\n\n    if (forSquare) {\n      // illegal square, return empty moves\n      if (!(forSquare in Ox88)) {\n        return [];\n      } else {\n        firstSquare = lastSquare = Ox88[forSquare];\n        singleSquare = true;\n      }\n    }\n\n    for (let from = firstSquare; from <= lastSquare; from++) {\n      /* did we run off the end of the board */\n      if (from & 0x88) {\n        from += 7;\n        continue;\n      } // empty square or opponent, skip\n\n\n      if (!this._board[from] || this._board[from].color === them) {\n        continue;\n      }\n\n      const {\n        type\n      } = this._board[from];\n      let to;\n\n      if (type === exports.PAWN) {\n        if (forPiece && forPiece !== type) continue;\n        /* single square, non-capturing */\n\n        to = from + PAWN_OFFSETS[us][0];\n\n        if (!this._board[to]) {\n          addMove(moves, us, from, to, exports.PAWN);\n          /* double square */\n\n          to = from + PAWN_OFFSETS[us][1];\n\n          if (SECOND_RANK[us] === rank(from) && !this._board[to]) {\n            addMove(moves, us, from, to, exports.PAWN, undefined, BITS.BIG_PAWN);\n          }\n        }\n        /* pawn captures */\n\n\n        for (let j = 2; j < 4; j++) {\n          to = from + PAWN_OFFSETS[us][j];\n          if (to & 0x88) continue;\n\n          if (((_a = this._board[to]) === null || _a === void 0 ? void 0 : _a.color) === them) {\n            addMove(moves, us, from, to, exports.PAWN, this._board[to].type, BITS.CAPTURE);\n          } else if (to === this._epSquare) {\n            addMove(moves, us, from, to, exports.PAWN, exports.PAWN, BITS.EP_CAPTURE);\n          }\n        }\n      } else {\n        if (forPiece && forPiece !== type) continue;\n\n        for (let j = 0, len = PIECE_OFFSETS[type].length; j < len; j++) {\n          const offset = PIECE_OFFSETS[type][j];\n          to = from;\n\n          while (true) {\n            to += offset;\n            if (to & 0x88) break;\n\n            if (!this._board[to]) {\n              addMove(moves, us, from, to, type);\n            } else {\n              // own color, stop loop\n              if (this._board[to].color === us) break;\n              addMove(moves, us, from, to, type, this._board[to].type, BITS.CAPTURE);\n              break;\n            }\n            /* break, if knight or king */\n\n\n            if (type === exports.KNIGHT || type === exports.KING) break;\n          }\n        }\n      }\n    }\n    /* check for castling if:\n     * a) we're generating all moves, or\n     * b) we're doing single square move generation on the king's square\n     */\n\n\n    if (forPiece === undefined || forPiece === exports.KING) {\n      if (!singleSquare || lastSquare === this._kings[us]) {\n        /* king-side castling */\n        if (this._castling[us] & BITS.KSIDE_CASTLE) {\n          const castlingFrom = this._kings[us];\n          const castlingTo = castlingFrom + 2;\n\n          if (!this._board[castlingFrom + 1] && !this._board[castlingTo] && !this._attacked(them, this._kings[us]) && !this._attacked(them, castlingFrom + 1) && !this._attacked(them, castlingTo)) {\n            addMove(moves, us, this._kings[us], castlingTo, exports.KING, undefined, BITS.KSIDE_CASTLE);\n          }\n        }\n        /* queen-side castling */\n\n\n        if (this._castling[us] & BITS.QSIDE_CASTLE) {\n          const castlingFrom = this._kings[us];\n          const castlingTo = castlingFrom - 2;\n\n          if (!this._board[castlingFrom - 1] && !this._board[castlingFrom - 2] && !this._board[castlingFrom - 3] && !this._attacked(them, this._kings[us]) && !this._attacked(them, castlingFrom - 1) && !this._attacked(them, castlingTo)) {\n            addMove(moves, us, this._kings[us], castlingTo, exports.KING, undefined, BITS.QSIDE_CASTLE);\n          }\n        }\n      }\n    }\n    /* return all pseudo-legal moves (this includes moves that allow the king\n     * to be captured) */\n\n\n    if (!legal) {\n      return moves;\n    }\n    /* filter out illegal moves */\n\n\n    const legalMoves = [];\n\n    for (let i = 0, len = moves.length; i < len; i++) {\n      this._makeMove(moves[i]);\n\n      if (!this._isKingAttacked(us)) {\n        legalMoves.push(moves[i]);\n      }\n\n      this._undoMove();\n    }\n\n    return legalMoves;\n  }\n\n  move(move) {\n    let {\n      sloppy = false\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    /* The move function can be called with in the following parameters:\n        *\n        * .move('Nxb7')      <- where 'move' is a case-sensitive SAN string\n        *\n        * .move({ from: 'h7', <- where the 'move' is a move object\n        (additional\n        *         to :'h8',      fields are ignored)\n        *         promotion: 'q',\n        *      })\n        */\n    // sloppy parser allows the move parser to work around over disambiguation\n    // bugs in Fritz and Chessbase\n    let moveObj = null;\n\n    if (typeof move === 'string') {\n      moveObj = this._moveFromSan(move, sloppy);\n    } else if (typeof move === 'object') {\n      const moves = this._moves();\n      /* convert the pretty move object to an ugly move object */\n\n\n      for (let i = 0, len = moves.length; i < len; i++) {\n        if (move.from === algebraic(moves[i].from) && move.to === algebraic(moves[i].to) && (!('promotion' in moves[i]) || move.promotion === moves[i].promotion)) {\n          moveObj = moves[i];\n          break;\n        }\n      }\n    }\n    /* failed to find move */\n\n\n    if (!moveObj) {\n      return null;\n    }\n    /* need to make a copy of move because we can't generate SAN after\n       the move is made */\n\n\n    const prettyMove = this._makePretty(moveObj);\n\n    this._makeMove(moveObj);\n\n    return prettyMove;\n  }\n\n  _push(move) {\n    this._history.push({\n      move,\n      kings: {\n        b: this._kings.b,\n        w: this._kings.w\n      },\n      turn: this._turn,\n      castling: {\n        b: this._castling.b,\n        w: this._castling.w\n      },\n      epSquare: this._epSquare,\n      halfMoves: this._halfMoves,\n      moveNumber: this._moveNumber\n    });\n  }\n\n  _makeMove(move) {\n    const us = this._turn;\n    const them = swapColor(us);\n\n    this._push(move);\n\n    this._board[move.to] = this._board[move.from];\n    delete this._board[move.from];\n    /* if ep capture, remove the captured pawn */\n\n    if (move.flags & BITS.EP_CAPTURE) {\n      if (this._turn === exports.BLACK) {\n        delete this._board[move.to - 16];\n      } else {\n        delete this._board[move.to + 16];\n      }\n    }\n    /* if pawn promotion, replace with new piece */\n\n\n    if (move.promotion) {\n      this._board[move.to] = {\n        type: move.promotion,\n        color: us\n      };\n    }\n    /* if we moved the king */\n\n\n    if (this._board[move.to].type === exports.KING) {\n      this._kings[us] = move.to;\n      /* if we castled, move the rook next to the king */\n\n      if (move.flags & BITS.KSIDE_CASTLE) {\n        const castlingTo = move.to - 1;\n        const castlingFrom = move.to + 1;\n        this._board[castlingTo] = this._board[castlingFrom];\n        delete this._board[castlingFrom];\n      } else if (move.flags & BITS.QSIDE_CASTLE) {\n        const castlingTo = move.to + 1;\n        const castlingFrom = move.to - 2;\n        this._board[castlingTo] = this._board[castlingFrom];\n        delete this._board[castlingFrom];\n      }\n      /* turn off castling */\n\n\n      this._castling[us] = 0;\n    }\n    /* turn off castling if we move a rook */\n\n\n    if (this._castling[us]) {\n      for (let i = 0, len = ROOKS[us].length; i < len; i++) {\n        if (move.from === ROOKS[us][i].square && this._castling[us] & ROOKS[us][i].flag) {\n          this._castling[us] ^= ROOKS[us][i].flag;\n          break;\n        }\n      }\n    }\n    /* turn off castling if we capture a rook */\n\n\n    if (this._castling[them]) {\n      for (let i = 0, len = ROOKS[them].length; i < len; i++) {\n        if (move.to === ROOKS[them][i].square && this._castling[them] & ROOKS[them][i].flag) {\n          this._castling[them] ^= ROOKS[them][i].flag;\n          break;\n        }\n      }\n    }\n    /* if big pawn move, update the en passant square */\n\n\n    if (move.flags & BITS.BIG_PAWN) {\n      if (us === exports.BLACK) {\n        this._epSquare = move.to - 16;\n      } else {\n        this._epSquare = move.to + 16;\n      }\n    } else {\n      this._epSquare = EMPTY;\n    }\n    /* reset the 50 move counter if a pawn is moved or a piece is captured */\n\n\n    if (move.piece === exports.PAWN) {\n      this._halfMoves = 0;\n    } else if (move.flags & (BITS.CAPTURE | BITS.EP_CAPTURE)) {\n      this._halfMoves = 0;\n    } else {\n      this._halfMoves++;\n    }\n\n    if (us === exports.BLACK) {\n      this._moveNumber++;\n    }\n\n    this._turn = them;\n  }\n\n  undo() {\n    const move = this._undoMove();\n\n    return move ? this._makePretty(move) : null;\n  }\n\n  _undoMove() {\n    const old = this._history.pop();\n\n    if (old === undefined) {\n      return null;\n    }\n\n    const move = old.move;\n    this._kings = old.kings;\n    this._turn = old.turn;\n    this._castling = old.castling;\n    this._epSquare = old.epSquare;\n    this._halfMoves = old.halfMoves;\n    this._moveNumber = old.moveNumber;\n    const us = this._turn;\n    const them = swapColor(us);\n    this._board[move.from] = this._board[move.to];\n    this._board[move.from].type = move.piece; // to undo any promotions\n\n    delete this._board[move.to];\n\n    if (move.captured) {\n      if (move.flags & BITS.EP_CAPTURE) {\n        // en passant capture\n        let index;\n\n        if (us === exports.BLACK) {\n          index = move.to - 16;\n        } else {\n          index = move.to + 16;\n        }\n\n        this._board[index] = {\n          type: exports.PAWN,\n          color: them\n        };\n      } else {\n        // regular capture\n        this._board[move.to] = {\n          type: move.captured,\n          color: them\n        };\n      }\n    }\n\n    if (move.flags & (BITS.KSIDE_CASTLE | BITS.QSIDE_CASTLE)) {\n      let castlingTo, castlingFrom;\n\n      if (move.flags & BITS.KSIDE_CASTLE) {\n        castlingTo = move.to + 1;\n        castlingFrom = move.to - 1;\n      } else {\n        castlingTo = move.to - 2;\n        castlingFrom = move.to + 1;\n      }\n\n      this._board[castlingTo] = this._board[castlingFrom];\n      delete this._board[castlingFrom];\n    }\n\n    return move;\n  }\n\n  pgn() {\n    let {\n      newline = '\\n',\n      maxWidth = 0\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    /* using the specification from http://www.chessclub.com/help/PGN-spec\n     * example for html usage: .pgn({ max_width: 72, newline_char: \"<br />\" })\n     */\n    const result = [];\n    let headerExists = false;\n    /* add the PGN header information */\n\n    for (const i in this._header) {\n      /* TODO: order of enumerated properties in header object is not\n       * guaranteed, see ECMA-262 spec (section 12.6.4)\n       */\n      result.push('[' + i + ' \"' + this._header[i] + '\"]' + newline);\n      headerExists = true;\n    }\n\n    if (headerExists && this._history.length) {\n      result.push(newline);\n    }\n\n    const appendComment = moveString => {\n      const comment = this._comments[this.fen()];\n\n      if (typeof comment !== 'undefined') {\n        const delimiter = moveString.length > 0 ? ' ' : '';\n        moveString = `${moveString}${delimiter}{${comment}}`;\n      }\n\n      return moveString;\n    };\n    /* pop all of history onto reversed_history */\n\n\n    const reversedHistory = [];\n\n    while (this._history.length > 0) {\n      reversedHistory.push(this._undoMove());\n    }\n\n    const moves = [];\n    let moveString = '';\n    /* special case of a commented starting position with no moves */\n\n    if (reversedHistory.length === 0) {\n      moves.push(appendComment(''));\n    }\n    /* build the list of moves.  a move_string looks like: \"3. e3 e6\" */\n\n\n    while (reversedHistory.length > 0) {\n      moveString = appendComment(moveString);\n      const move = reversedHistory.pop(); // make TypeScript stop complaining about move being undefined\n\n      if (!move) {\n        break;\n      }\n      /* if the position started with black to move, start PGN with #. ... */\n\n\n      if (!this._history.length && move.color === 'b') {\n        const prefix = `${this._moveNumber}. ...`;\n        /* is there a comment preceding the first move? */\n\n        moveString = moveString ? `${moveString} ${prefix}` : prefix;\n      } else if (move.color === 'w') {\n        /* store the previous generated move_string if we have one */\n        if (moveString.length) {\n          moves.push(moveString);\n        }\n\n        moveString = this._moveNumber + '.';\n      }\n\n      moveString = moveString + ' ' + this._moveToSan(move, this._moves({\n        legal: true\n      }));\n\n      this._makeMove(move);\n    }\n    /* are there any other leftover moves? */\n\n\n    if (moveString.length) {\n      moves.push(appendComment(moveString));\n    }\n    /* is there a result? */\n\n\n    if (typeof this._header.Result !== 'undefined') {\n      moves.push(this._header.Result);\n    }\n    /* history should be back to what it was before we started generating PGN,\n     * so join together moves\n     */\n\n\n    if (maxWidth === 0) {\n      return result.join('') + moves.join(' ');\n    } // JAH: huh?\n\n\n    const strip = function () {\n      if (result.length > 0 && result[result.length - 1] === ' ') {\n        result.pop();\n        return true;\n      }\n\n      return false;\n    };\n    /* NB: this does not preserve comment whitespace. */\n\n\n    const wrapComment = function (width, move) {\n      for (const token of move.split(' ')) {\n        if (!token) {\n          continue;\n        }\n\n        if (width + token.length > maxWidth) {\n          while (strip()) {\n            width--;\n          }\n\n          result.push(newline);\n          width = 0;\n        }\n\n        result.push(token);\n        width += token.length;\n        result.push(' ');\n        width++;\n      }\n\n      if (strip()) {\n        width--;\n      }\n\n      return width;\n    };\n    /* wrap the PGN output at max_width */\n\n\n    let currentWidth = 0;\n\n    for (let i = 0; i < moves.length; i++) {\n      if (currentWidth + moves[i].length > maxWidth) {\n        if (moves[i].includes('{')) {\n          currentWidth = wrapComment(currentWidth, moves[i]);\n          continue;\n        }\n      }\n      /* if the current move will push past max_width */\n\n\n      if (currentWidth + moves[i].length > maxWidth && i !== 0) {\n        /* don't end the line with whitespace */\n        if (result[result.length - 1] === ' ') {\n          result.pop();\n        }\n\n        result.push(newline);\n        currentWidth = 0;\n      } else if (i !== 0) {\n        result.push(' ');\n        currentWidth++;\n      }\n\n      result.push(moves[i]);\n      currentWidth += moves[i].length;\n    }\n\n    return result.join('');\n  }\n\n  header() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    for (let i = 0; i < args.length; i += 2) {\n      if (typeof args[i] === 'string' && typeof args[i + 1] === 'string') {\n        this._header[args[i]] = args[i + 1];\n      }\n    }\n\n    return this._header;\n  }\n\n  loadPgn(pgn) {\n    let {\n      sloppy = false,\n      newlineChar = '\\r?\\n'\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    // option sloppy=true\n    // allow the user to specify the sloppy move parser to work around over\n    // disambiguation bugs in Fritz and Chessbase\n    function mask(str) {\n      return str.replace(/\\\\/g, '\\\\');\n    }\n\n    function parsePgnHeader(header) {\n      const headerObj = {};\n      const headers = header.split(new RegExp(mask(newlineChar)));\n      let key = '';\n      let value = '';\n\n      for (let i = 0; i < headers.length; i++) {\n        const regex = /^\\s*\\[([A-Za-z]+)\\s*\"(.*)\"\\s*\\]\\s*$/;\n        key = headers[i].replace(regex, '$1');\n        value = headers[i].replace(regex, '$2');\n\n        if (key.trim().length > 0) {\n          headerObj[key] = value;\n        }\n      }\n\n      return headerObj;\n    } // strip whitespace from head/tail of PGN block\n\n\n    pgn = pgn.trim(); // RegExp to split header. Takes advantage of the fact that header and movetext\n    // will always have a blank line between them (ie, two newline_char's).\n    // With default newline_char, will equal: /^(\\[((?:\\r?\\n)|.)*\\])(?:\\s*\\r?\\n){2}/\n\n    const headerRegex = new RegExp('^(\\\\[((?:' + mask(newlineChar) + ')|.)*\\\\])' + '(?:\\\\s*' + mask(newlineChar) + '){2}'); // If no header given, begin with moves.\n\n    const headerRegexResults = headerRegex.exec(pgn);\n    const headerString = headerRegexResults ? headerRegexResults.length >= 2 ? headerRegexResults[1] : '' : ''; // Put the board in the starting position\n\n    this.reset();\n    /* parse PGN header */\n\n    const headers = parsePgnHeader(headerString);\n    let fen = '';\n\n    for (const key in headers) {\n      // check to see user is including fen (possibly with wrong tag case)\n      if (key.toLowerCase() === 'fen') {\n        fen = headers[key];\n      }\n\n      this.header(key, headers[key]);\n    }\n    /* sloppy parser should attempt to load a fen tag, even if it's\n     * the wrong case and doesn't include a corresponding [SetUp \"1\"] tag */\n\n\n    if (sloppy) {\n      if (fen) {\n        if (!this.load(fen, true)) {\n          return false;\n        }\n      }\n    } else {\n      /* strict parser - load the starting position indicated by [Setup '1']\n       * and [FEN position] */\n      if (headers['SetUp'] === '1') {\n        if (!('FEN' in headers && this.load(headers['FEN'], true))) {\n          // second argument to load: don't clear the headers\n          return false;\n        }\n      }\n    }\n    /* NB: the regexes below that delete move numbers, recursive\n     * annotations, and numeric annotation glyphs may also match\n     * text in comments. To prevent this, we transform comments\n     * by hex-encoding them in place and decoding them again after\n     * the other tokens have been deleted.\n     *\n     * While the spec states that PGN files should be ASCII encoded,\n     * we use {en,de}codeURIComponent here to support arbitrary UTF8\n     * as a convenience for modern users */\n\n\n    function toHex(s) {\n      return Array.from(s).map(function (c) {\n        /* encodeURI doesn't transform most ASCII characters,\n         * so we handle these ourselves */\n        return c.charCodeAt(0) < 128 ? c.charCodeAt(0).toString(16) : encodeURIComponent(c).replace(/%/g, '').toLowerCase();\n      }).join('');\n    }\n\n    function fromHex(s) {\n      return s.length == 0 ? '' : decodeURIComponent('%' + (s.match(/.{1,2}/g) || []).join('%'));\n    }\n\n    const encodeComment = function (s) {\n      s = s.replace(new RegExp(mask(newlineChar), 'g'), ' ');\n      return `{${toHex(s.slice(1, s.length - 1))}}`;\n    };\n\n    const decodeComment = function (s) {\n      if (s.startsWith('{') && s.endsWith('}')) {\n        return fromHex(s.slice(1, s.length - 1));\n      }\n    };\n    /* delete header to get the moves */\n\n\n    let ms = pgn.replace(headerString, '').replace(\n    /* encode comments so they don't get deleted below */\n    new RegExp(`({[^}]*})+?|;([^${mask(newlineChar)}]*)`, 'g'), function (_match, bracket, semicolon) {\n      return bracket !== undefined ? encodeComment(bracket) : ' ' + encodeComment(`{${semicolon.slice(1)}}`);\n    }).replace(new RegExp(mask(newlineChar), 'g'), ' ');\n    /* delete recursive annotation variations */\n\n    const ravRegex = /(\\([^()]+\\))+?/g;\n\n    while (ravRegex.test(ms)) {\n      ms = ms.replace(ravRegex, '');\n    }\n    /* delete move numbers */\n\n\n    ms = ms.replace(/\\d+\\.(\\.\\.)?/g, '');\n    /* delete ... indicating black to move */\n\n    ms = ms.replace(/\\.\\.\\./g, '');\n    /* delete numeric annotation glyphs */\n\n    ms = ms.replace(/\\$\\d+/g, '');\n    /* trim and get array of moves */\n\n    let moves = ms.trim().split(new RegExp(/\\s+/));\n    /* delete empty entries */\n\n    moves = moves.join(',').replace(/,,+/g, ',').split(',');\n    let result = '';\n\n    for (let halfMove = 0; halfMove < moves.length; halfMove++) {\n      const comment = decodeComment(moves[halfMove]);\n\n      if (comment !== undefined) {\n        this._comments[this.fen()] = comment;\n        continue;\n      }\n\n      const move = this._moveFromSan(moves[halfMove], sloppy);\n      /* invalid move */\n\n\n      if (move == null) {\n        /* was the move an end of game marker */\n        if (TERMINATION_MARKERS.indexOf(moves[halfMove]) > -1) {\n          result = moves[halfMove];\n        } else {\n          return false;\n        }\n      } else {\n        /* reset the end of game marker if making a valid move */\n        result = '';\n\n        this._makeMove(move);\n      }\n    }\n    /* Per section 8.2.6 of the PGN spec, the Result tag pair must match\n    * match the termination marker. Only do this when headers are\n        present,\n        * but the result tag is missing\n        */\n\n\n    if (result && Object.keys(this._header).length && !this._header['Result']) {\n      this.header('Result', result);\n    }\n\n    return true;\n  }\n  /* convert a move from 0x88 coordinates to Standard Algebraic Notation\n    * (SAN)\n    *\n    * @param {boolean} sloppy Use the sloppy SAN generator to work around\n    over\n    * disambiguation bugs in Fritz and Chessbase.  See below:\n    *\n    * r1bqkbnr/ppp2ppp/2n5/1B1pP3/4P3/8/PPPP2PP/RNBQK1NR b KQkq - 2 4\n    * 4. ... Nge7 is overly disambiguated because the knight on c6 is pinned\n    * 4. ... Ne7 is technically the valid SAN\n    */\n\n\n  _moveToSan(move, moves) {\n    let output = '';\n\n    if (move.flags & BITS.KSIDE_CASTLE) {\n      output = 'O-O';\n    } else if (move.flags & BITS.QSIDE_CASTLE) {\n      output = 'O-O-O';\n    } else {\n      if (move.piece !== exports.PAWN) {\n        const disambiguator = getDisambiguator(move, moves);\n        output += move.piece.toUpperCase() + disambiguator;\n      }\n\n      if (move.flags & (BITS.CAPTURE | BITS.EP_CAPTURE)) {\n        if (move.piece === exports.PAWN) {\n          output += algebraic(move.from)[0];\n        }\n\n        output += 'x';\n      }\n\n      output += algebraic(move.to);\n\n      if (move.promotion) {\n        output += '=' + move.promotion.toUpperCase();\n      }\n    }\n\n    this._makeMove(move);\n\n    if (this.isCheck()) {\n      if (this.isCheckmate()) {\n        output += '#';\n      } else {\n        output += '+';\n      }\n    }\n\n    this._undoMove();\n\n    return output;\n  } // convert a move from Standard Algebraic Notation (SAN) to 0x88\n  // coordinates\n\n\n  _moveFromSan(move) {\n    let sloppy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    // strip off any move decorations: e.g Nf3+?! becomes Nf3\n    const cleanMove = strippedSan(move);\n    let pieceType = inferPieceType(cleanMove);\n\n    let moves = this._moves({\n      legal: true,\n      piece: pieceType\n    }); // strict parser\n\n\n    for (let i = 0, len = moves.length; i < len; i++) {\n      if (cleanMove === strippedSan(this._moveToSan(moves[i], moves))) {\n        return moves[i];\n      }\n    } // strict parser failed and the sloppy parser wasn't used, return null\n\n\n    if (!sloppy) {\n      return null;\n    }\n\n    let piece = undefined;\n    let matches = undefined;\n    let from = undefined;\n    let to = undefined;\n    let promotion = undefined; // The sloppy parser allows the user to parse non-standard chess\n    // notations. This parser is opt-in (by specifying the\n    // '{ sloppy: true }' setting) and is only run after the Standard\n    // Algebraic Notation (SAN) parser has failed.\n    //\n    // When running the sloppy parser, we'll run a regex to grab the piece,\n    // the to/from square, and an optional promotion piece. This regex will\n    // parse common non-standard notation like: Pe2-e4, Rc1c4, Qf3xf7,\n    // f7f8q, b1c3\n    // NOTE: Some positions and moves may be ambiguous when using the\n    // sloppy parser. For example, in this position:\n    // 6k1/8/8/B7/8/8/8/BN4K1 w - - 0 1, the move b1c3 may be interpreted\n    // as Nc3 or B1c3 (a disambiguated bishop move). In these cases, the\n    // sloppy parser will default to the most most basic interpretation\n    // (which is b1c3 parsing to Nc3).\n    // FIXME: these var's are hoisted into function scope, this will need\n    // to change when switching to const/let\n\n    let overlyDisambiguated = false;\n    matches = cleanMove.match(/([pnbrqkPNBRQK])?([a-h][1-8])x?-?([a-h][1-8])([qrbnQRBN])?/ //     piece         from              to       promotion\n    );\n\n    if (matches) {\n      piece = matches[1];\n      from = matches[2];\n      to = matches[3];\n      promotion = matches[4];\n\n      if (from.length == 1) {\n        overlyDisambiguated = true;\n      }\n    } else {\n      // The [a-h]?[1-8]? portion of the regex below handles moves that may\n      // be overly disambiguated (e.g. Nge7 is unnecessary and non-standard\n      // when there is one legal knight move to e7). In this case, the value\n      // of 'from' variable will be a rank or file, not a square.\n      matches = cleanMove.match(/([pnbrqkPNBRQK])?([a-h]?[1-8]?)x?-?([a-h][1-8])([qrbnQRBN])?/);\n\n      if (matches) {\n        piece = matches[1];\n        from = matches[2];\n        to = matches[3];\n        promotion = matches[4];\n\n        if (from.length == 1) {\n          overlyDisambiguated = true;\n        }\n      }\n    }\n\n    pieceType = inferPieceType(cleanMove);\n    moves = this._moves({\n      legal: true,\n      piece: piece ? piece : pieceType\n    });\n\n    for (let i = 0, len = moves.length; i < len; i++) {\n      if (from && to) {\n        // hand-compare move properties with the results from our sloppy\n        // regex\n        if ((!piece || piece.toLowerCase() == moves[i].piece) && Ox88[from] == moves[i].from && Ox88[to] == moves[i].to && (!promotion || promotion.toLowerCase() == moves[i].promotion)) {\n          return moves[i];\n        } else if (overlyDisambiguated) {\n          // SPECIAL CASE: we parsed a move string that may have an\n          // unneeded rank/file disambiguator (e.g. Nge7).  The 'from'\n          // variable will\n          const square = algebraic(moves[i].from);\n\n          if ((!piece || piece.toLowerCase() == moves[i].piece) && Ox88[to] == moves[i].to && (from == square[0] || from == square[1]) && (!promotion || promotion.toLowerCase() == moves[i].promotion)) {\n            return moves[i];\n          }\n        }\n      }\n    }\n\n    return null;\n  }\n\n  ascii() {\n    let s = '   +------------------------+\\n';\n\n    for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n      /* display the rank */\n      if (file(i) === 0) {\n        s += ' ' + '87654321'[rank(i)] + ' |';\n      }\n\n      if (this._board[i]) {\n        const piece = this._board[i].type;\n        const color = this._board[i].color;\n        const symbol = color === exports.WHITE ? piece.toUpperCase() : piece.toLowerCase();\n        s += ' ' + symbol + ' ';\n      } else {\n        s += ' . ';\n      }\n\n      if (i + 1 & 0x88) {\n        s += '|\\n';\n        i += 8;\n      }\n    }\n\n    s += '   +------------------------+\\n';\n    s += '     a  b  c  d  e  f  g  h';\n    return s;\n  }\n\n  perft(depth) {\n    const moves = this._moves({\n      legal: false\n    });\n\n    let nodes = 0;\n    const color = this._turn;\n\n    for (let i = 0, len = moves.length; i < len; i++) {\n      this._makeMove(moves[i]);\n\n      if (!this._isKingAttacked(color)) {\n        if (depth - 1 > 0) {\n          nodes += this.perft(depth - 1);\n        } else {\n          nodes++;\n        }\n      }\n\n      this._undoMove();\n    }\n\n    return nodes;\n  }\n  /* pretty = external move object */\n\n\n  _makePretty(uglyMove) {\n    const {\n      color,\n      piece,\n      from,\n      to,\n      flags,\n      captured,\n      promotion\n    } = uglyMove;\n    let prettyFlags = '';\n\n    for (const flag in BITS) {\n      if (BITS[flag] & flags) {\n        prettyFlags += FLAGS[flag];\n      }\n    }\n\n    const move = {\n      color,\n      piece,\n      from: algebraic(from),\n      to: algebraic(to),\n      san: this._moveToSan(uglyMove, this._moves({\n        legal: true\n      })),\n      flags: prettyFlags\n    };\n\n    if (captured) {\n      move.captured = captured;\n    }\n\n    if (promotion) {\n      move.promotion = promotion;\n    }\n\n    return move;\n  }\n\n  turn() {\n    return this._turn;\n  }\n\n  board() {\n    const output = [];\n    let row = [];\n\n    for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n      if (this._board[i] == null) {\n        row.push(null);\n      } else {\n        row.push({\n          square: algebraic(i),\n          type: this._board[i].type,\n          color: this._board[i].color\n        });\n      }\n\n      if (i + 1 & 0x88) {\n        output.push(row);\n        row = [];\n        i += 8;\n      }\n    }\n\n    return output;\n  }\n\n  squareColor(square) {\n    if (square in Ox88) {\n      const sq = Ox88[square];\n      return (rank(sq) + file(sq)) % 2 === 0 ? 'light' : 'dark';\n    }\n\n    return null;\n  }\n\n  history() {\n    let {\n      verbose = false\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const reversedHistory = [];\n    const moveHistory = [];\n\n    while (this._history.length > 0) {\n      reversedHistory.push(this._undoMove());\n    }\n\n    while (true) {\n      const move = reversedHistory.pop();\n\n      if (!move) {\n        break;\n      }\n\n      if (verbose) {\n        moveHistory.push(this._makePretty(move));\n      } else {\n        moveHistory.push(this._moveToSan(move, this._moves()));\n      }\n\n      this._makeMove(move);\n    }\n\n    return moveHistory;\n  }\n\n  _pruneComments() {\n    const reversedHistory = [];\n    const currentComments = {};\n\n    const copyComment = fen => {\n      if (fen in this._comments) {\n        currentComments[fen] = this._comments[fen];\n      }\n    };\n\n    while (this._history.length > 0) {\n      reversedHistory.push(this._undoMove());\n    }\n\n    copyComment(this.fen());\n\n    while (true) {\n      const move = reversedHistory.pop();\n\n      if (!move) {\n        break;\n      }\n\n      this._makeMove(move);\n\n      copyComment(this.fen());\n    }\n\n    this._comments = currentComments;\n  }\n\n  getComment() {\n    return this._comments[this.fen()];\n  }\n\n  setComment(comment) {\n    this._comments[this.fen()] = comment.replace('{', '[').replace('}', ']');\n  }\n\n  deleteComment() {\n    const comment = this._comments[this.fen()];\n\n    delete this._comments[this.fen()];\n    return comment;\n  }\n\n  getComments() {\n    this._pruneComments();\n\n    return Object.keys(this._comments).map(fen => {\n      return {\n        fen: fen,\n        comment: this._comments[fen]\n      };\n    });\n  }\n\n  deleteComments() {\n    this._pruneComments();\n\n    return Object.keys(this._comments).map(fen => {\n      const comment = this._comments[fen];\n      delete this._comments[fen];\n      return {\n        fen: fen,\n        comment: comment\n      };\n    });\n  }\n\n}\n\nexports.Chess = Chess; //   return {\n//     /***************************************************************************\n//      * PUBLIC CONSTANTS (is there a better way to do this?)\n//      **************************************************************************/\n//     SQUARES: (function () {\n//       /* from the ECMA-262 spec (section 12.6.4):\n//        * \"The mechanics of enumerating the properties ... is\n//        * implementation dependent\"\n//        * so: for (var sq in SQUARES) { keys.push(sq); } might not be\n//        * ordered correctly\n//        */\n//       var keys = []\n//       for (var i = SQUARES.a8; i <= SQUARES.h1; i++) {\n//         if (i & 0x88) {\n//           i += 7\n//           continue\n//         }\n//         keys.push(algebraic(i))\n//       }\n//       return keys\n//     })(),\n//     FLAGS: FLAGS,\n// }","map":{"version":3,"names":["Object","defineProperty","exports","value","Chess","validateFen","SQUARES","DEFAULT_POSITION","KING","QUEEN","ROOK","BISHOP","KNIGHT","PAWN","BLACK","WHITE","EMPTY","FLAGS","NORMAL","CAPTURE","BIG_PAWN","EP_CAPTURE","PROMOTION","KSIDE_CASTLE","QSIDE_CASTLE","BITS","Ox88","a8","b8","c8","d8","e8","f8","g8","h8","a7","b7","c7","d7","e7","f7","g7","h7","a6","b6","c6","d6","e6","f6","g6","h6","a5","b5","c5","d5","e5","f5","g5","h5","a4","b4","c4","d4","e4","f4","g4","h4","a3","b3","c3","d3","e3","f3","g3","h3","a2","b2","c2","d2","e2","f2","g2","h2","a1","b1","c1","d1","e1","f1","g1","h1","PAWN_OFFSETS","b","w","PIECE_OFFSETS","n","r","q","k","ATTACKS","RAYS","PIECE_MASKS","p","SYMBOLS","PROMOTIONS","RANK_1","RANK_2","RANK_7","RANK_8","ROOKS","square","flag","SECOND_RANK","TERMINATION_MARKERS","rank","file","isDigit","c","indexOf","algebraic","f","substring","swapColor","color","fen","errors","tokens","split","length","valid","errorNumber","error","moveNumber","parseInt","isNaN","halfMoves","test","rows","i","sumFields","previousWasNumber","getDisambiguator","move","moves","from","to","piece","ambiguities","sameRank","sameFile","len","ambigFrom","ambigTo","ambigPiece","charAt","addMove","captured","undefined","flags","promotion","push","inferPieceType","san","pieceType","matches","match","toLowerCase","strippedSan","replace","constructor","_board","Array","_turn","_header","_kings","_epSquare","_halfMoves","_moveNumber","_history","_comments","_castling","load","clear","keepHeaders","_updateSetup","position","put","type","empty","toUpperCase","cflags","epflags","join","reset","get","sq","remove","_attacked","difference","index","offset","j","blocked","_isKingAttacked","isCheck","inCheck","isCheckmate","_moves","isStalemate","isInsufficientMaterial","pieces","bishops","numPieces","squareColor","sum","isThreefoldRepetition","positions","repetition","_undoMove","slice","pop","_makeMove","isDraw","isGameOver","verbose","map","_makePretty","_moveToSan","legal","_a","forSquare","forPiece","us","them","firstSquare","lastSquare","singleSquare","castlingFrom","castlingTo","legalMoves","sloppy","moveObj","_moveFromSan","prettyMove","_push","kings","turn","castling","epSquare","undo","old","pgn","newline","maxWidth","result","headerExists","appendComment","moveString","comment","delimiter","reversedHistory","prefix","Result","strip","wrapComment","width","token","currentWidth","includes","header","args","loadPgn","newlineChar","mask","str","parsePgnHeader","headerObj","headers","RegExp","key","regex","trim","headerRegex","headerRegexResults","exec","headerString","toHex","s","charCodeAt","toString","encodeURIComponent","fromHex","decodeURIComponent","encodeComment","decodeComment","startsWith","endsWith","ms","_match","bracket","semicolon","ravRegex","halfMove","keys","output","disambiguator","cleanMove","overlyDisambiguated","ascii","symbol","perft","depth","nodes","uglyMove","prettyFlags","board","row","history","moveHistory","_pruneComments","currentComments","copyComment","getComment","setComment","deleteComment","getComments","deleteComments"],"sources":["C:/Users/tomas/Desktop/chess-masterclass/backend/chess_masterclass/frontend_chessmasterclass/node_modules/chess.js/dist/chess.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Chess = exports.validateFen = exports.SQUARES = exports.DEFAULT_POSITION = exports.KING = exports.QUEEN = exports.ROOK = exports.BISHOP = exports.KNIGHT = exports.PAWN = exports.BLACK = exports.WHITE = void 0;\n/*\n * Copyright (c) 2022, Jeff Hlywa (jhlywa@gmail.com)\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *\n *----------------------------------------------------------------------------*/\nexports.WHITE = 'w';\nexports.BLACK = 'b';\nexports.PAWN = 'p';\nexports.KNIGHT = 'n';\nexports.BISHOP = 'b';\nexports.ROOK = 'r';\nexports.QUEEN = 'q';\nexports.KING = 'k';\nexports.DEFAULT_POSITION = 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1';\nconst EMPTY = -1;\nconst FLAGS = {\n    NORMAL: 'n',\n    CAPTURE: 'c',\n    BIG_PAWN: 'b',\n    EP_CAPTURE: 'e',\n    PROMOTION: 'p',\n    KSIDE_CASTLE: 'k',\n    QSIDE_CASTLE: 'q',\n};\n// prettier-ignore\nexports.SQUARES = [\n    'a8', 'b8', 'c8', 'd8', 'e8', 'f8', 'g8', 'h8',\n    'a7', 'b7', 'c7', 'd7', 'e7', 'f7', 'g7', 'h7',\n    'a6', 'b6', 'c6', 'd6', 'e6', 'f6', 'g6', 'h6',\n    'a5', 'b5', 'c5', 'd5', 'e5', 'f5', 'g5', 'h5',\n    'a4', 'b4', 'c4', 'd4', 'e4', 'f4', 'g4', 'h4',\n    'a3', 'b3', 'c3', 'd3', 'e3', 'f3', 'g3', 'h3',\n    'a2', 'b2', 'c2', 'd2', 'e2', 'f2', 'g2', 'h2',\n    'a1', 'b1', 'c1', 'd1', 'e1', 'f1', 'g1', 'h1'\n];\nconst BITS = {\n    NORMAL: 1,\n    CAPTURE: 2,\n    BIG_PAWN: 4,\n    EP_CAPTURE: 8,\n    PROMOTION: 16,\n    KSIDE_CASTLE: 32,\n    QSIDE_CASTLE: 64,\n};\n// NOTES ABOUT 0x88 MOVE GENERATION ALGORITHM\n// ----------------------------------------------------------------------------\n// From https://github.com/jhlywa/chess.js/issues/230\n//\n// A lot of people are confused when they first see the internal representation\n// of chess.js. It uses the 0x88 Move Generation Algorithm which internally\n// stores the board as an 8x16 array. This is purely for efficiency but has a\n// couple of interesting benefits:\n//\n// 1. 0x88 offers a very inexpensive \"off the board\" check. Bitwise AND (&) any\n//    square with 0x88, if the result is non-zero then the square is off the\n//    board. For example, assuming a knight square A8 (0 in 0x88 notation),\n//    there are 8 possible directions in which the knight can move. These\n//    directions are relative to the 8x16 board and are stored in the\n//    PIECE_OFFSETS map. One possible move is A8 - 18 (up one square, and two\n//    squares to the left - which is off the board). 0 - 18 = -18 & 0x88 = 0x88\n//    (because of two-complement representation of -18). The non-zero result\n//    means the square is off the board and the move is illegal. Take the\n//    opposite move (from A8 to C7), 0 + 18 = 18 & 0x88 = 0. A result of zero\n//    means the square is on the board.\n//\n// 2. The relative distance (or difference) between two squares on a 8x16 board\n//    is unique and can be used to inexpensively determine if a piece on a\n//    square can attack any other arbitrary square. For example, let's see if a\n//    pawn on E7 can attack E2. The difference between E7 (20) - E2 (100) is\n//    -80. We add 119 to make the ATTACKS array index non-negative (because the\n//    worst case difference is A8 - H1 = -119). The ATTACKS array contains a\n//    bitmask of pieces that can attack from that distance and direction.\n//    ATTACKS[-80 + 119=39] gives us 24 or 0b11000 in binary. Look at the\n//    PIECE_MASKS map to determine the mask for a given piece type. In our pawn\n//    example, we would check to see if 24 & 0x1 is non-zero, which it is\n//    not. So, naturally, a pawn on E7 can't attack a piece on E2. However, a\n//    rook can since 24 & 0x8 is non-zero. The only thing left to check is that\n//    there are no blocking pieces between E7 and E2. That's where the RAYS\n//    array comes in. It provides an offset (in this case 16) to add to E7 (20)\n//    to check for blocking pieces. E7 (20) + 16 = E6 (36) + 16 = E5 (52) etc.\n// prettier-ignore\nconst Ox88 = {\n    a8: 0, b8: 1, c8: 2, d8: 3, e8: 4, f8: 5, g8: 6, h8: 7,\n    a7: 16, b7: 17, c7: 18, d7: 19, e7: 20, f7: 21, g7: 22, h7: 23,\n    a6: 32, b6: 33, c6: 34, d6: 35, e6: 36, f6: 37, g6: 38, h6: 39,\n    a5: 48, b5: 49, c5: 50, d5: 51, e5: 52, f5: 53, g5: 54, h5: 55,\n    a4: 64, b4: 65, c4: 66, d4: 67, e4: 68, f4: 69, g4: 70, h4: 71,\n    a3: 80, b3: 81, c3: 82, d3: 83, e3: 84, f3: 85, g3: 86, h3: 87,\n    a2: 96, b2: 97, c2: 98, d2: 99, e2: 100, f2: 101, g2: 102, h2: 103,\n    a1: 112, b1: 113, c1: 114, d1: 115, e1: 116, f1: 117, g1: 118, h1: 119\n};\nconst PAWN_OFFSETS = {\n    b: [16, 32, 17, 15],\n    w: [-16, -32, -17, -15],\n};\nconst PIECE_OFFSETS = {\n    n: [-18, -33, -31, -14, 18, 33, 31, 14],\n    b: [-17, -15, 17, 15],\n    r: [-16, 1, 16, -1],\n    q: [-17, -16, -15, 1, 17, 16, 15, -1],\n    k: [-17, -16, -15, 1, 17, 16, 15, -1],\n};\n// prettier-ignore\nconst ATTACKS = [\n    20, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 20, 0,\n    0, 20, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 20, 0, 0,\n    0, 0, 20, 0, 0, 0, 0, 24, 0, 0, 0, 0, 20, 0, 0, 0,\n    0, 0, 0, 20, 0, 0, 0, 24, 0, 0, 0, 20, 0, 0, 0, 0,\n    0, 0, 0, 0, 20, 0, 0, 24, 0, 0, 20, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 20, 2, 24, 2, 20, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 2, 53, 56, 53, 2, 0, 0, 0, 0, 0, 0,\n    24, 24, 24, 24, 24, 24, 56, 0, 56, 24, 24, 24, 24, 24, 24, 0,\n    0, 0, 0, 0, 0, 2, 53, 56, 53, 2, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 20, 2, 24, 2, 20, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 20, 0, 0, 24, 0, 0, 20, 0, 0, 0, 0, 0,\n    0, 0, 0, 20, 0, 0, 0, 24, 0, 0, 0, 20, 0, 0, 0, 0,\n    0, 0, 20, 0, 0, 0, 0, 24, 0, 0, 0, 0, 20, 0, 0, 0,\n    0, 20, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 20, 0, 0,\n    20, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 20\n];\n// prettier-ignore\nconst RAYS = [\n    17, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 15, 0,\n    0, 17, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 15, 0, 0,\n    0, 0, 17, 0, 0, 0, 0, 16, 0, 0, 0, 0, 15, 0, 0, 0,\n    0, 0, 0, 17, 0, 0, 0, 16, 0, 0, 0, 15, 0, 0, 0, 0,\n    0, 0, 0, 0, 17, 0, 0, 16, 0, 0, 15, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 17, 0, 16, 0, 15, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 17, 16, 15, 0, 0, 0, 0, 0, 0, 0,\n    1, 1, 1, 1, 1, 1, 1, 0, -1, -1, -1, -1, -1, -1, -1, 0,\n    0, 0, 0, 0, 0, 0, -15, -16, -17, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, -15, 0, -16, 0, -17, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, -15, 0, 0, -16, 0, 0, -17, 0, 0, 0, 0, 0,\n    0, 0, 0, -15, 0, 0, 0, -16, 0, 0, 0, -17, 0, 0, 0, 0,\n    0, 0, -15, 0, 0, 0, 0, -16, 0, 0, 0, 0, -17, 0, 0, 0,\n    0, -15, 0, 0, 0, 0, 0, -16, 0, 0, 0, 0, 0, -17, 0, 0,\n    -15, 0, 0, 0, 0, 0, 0, -16, 0, 0, 0, 0, 0, 0, -17\n];\nconst PIECE_MASKS = { p: 0x1, n: 0x2, b: 0x4, r: 0x8, q: 0x10, k: 0x20 };\nconst SYMBOLS = 'pnbrqkPNBRQK';\nconst PROMOTIONS = [exports.KNIGHT, exports.BISHOP, exports.ROOK, exports.QUEEN];\nconst RANK_1 = 7;\nconst RANK_2 = 6;\n// const RANK_3 = 5\n// const RANK_4 = 4\n// const RANK_5 = 3\n// const RANK_6 = 2\nconst RANK_7 = 1;\nconst RANK_8 = 0;\nconst ROOKS = {\n    w: [\n        { square: Ox88.a1, flag: BITS.QSIDE_CASTLE },\n        { square: Ox88.h1, flag: BITS.KSIDE_CASTLE },\n    ],\n    b: [\n        { square: Ox88.a8, flag: BITS.QSIDE_CASTLE },\n        { square: Ox88.h8, flag: BITS.KSIDE_CASTLE },\n    ],\n};\nconst SECOND_RANK = { b: RANK_7, w: RANK_2 };\nconst TERMINATION_MARKERS = ['1-0', '0-1', '1/2-1/2', '*'];\n/**\n * Extracts the zero-based rank of an 0x88 square.\n */\nfunction rank(square) {\n    return square >> 4;\n}\n/**\n * Extracts the zero-based file of an 0x88 square.\n */\nfunction file(square) {\n    return square & 0xf;\n}\nfunction isDigit(c) {\n    return '0123456789'.indexOf(c) !== -1;\n}\n/**\n * Converts a 0x88 square to algebraic notation.\n */\nfunction algebraic(square) {\n    const f = file(square);\n    const r = rank(square);\n    return ('abcdefgh'.substring(f, f + 1) +\n        '87654321'.substring(r, r + 1));\n}\nfunction swapColor(color) {\n    return color === exports.WHITE ? exports.BLACK : exports.WHITE;\n}\n/* TODO: this needs a bit of work - it validates structure but completely\n * ignores content (e.g. doesn't verify that each side has a king) ... we should\n * rewrite this, and ditch the silly error_number field while we're at it */\nfunction validateFen(fen) {\n    const errors = [];\n    errors[0] = 'No errors.';\n    errors[1] = 'FEN string must contain six space-delimited fields.';\n    errors[2] = '6th field (move number) must be a positive integer.';\n    errors[3] = '5th field (half move counter) must be a non-negative integer.';\n    errors[4] = '4th field (en-passant square) is invalid.';\n    errors[5] = '3rd field (castling availability) is invalid.';\n    errors[6] = '2nd field (side to move) is invalid.';\n    errors[7] =\n        \"1st field (piece positions) does not contain 8 '/'-delimited rows.\";\n    errors[8] = '1st field (piece positions) is invalid [consecutive numbers].';\n    errors[9] = '1st field (piece positions) is invalid [invalid piece].';\n    errors[10] = '1st field (piece positions) is invalid [row too large].';\n    errors[11] = 'Illegal en-passant square';\n    /* 1st criterion: 6 space-seperated fields? */\n    const tokens = fen.split(/\\s+/);\n    if (tokens.length !== 6) {\n        return { valid: false, errorNumber: 1, error: errors[1] };\n    }\n    /* 2nd criterion: move number field is a integer value > 0? */\n    const moveNumber = parseInt(tokens[5], 10);\n    if (isNaN(moveNumber) || moveNumber <= 0) {\n        return { valid: false, errorNumber: 2, error: errors[2] };\n    }\n    /* 3rd criterion: half move counter is an integer >= 0? */\n    const halfMoves = parseInt(tokens[4], 10);\n    if (isNaN(halfMoves) || halfMoves < 0) {\n        return { valid: false, errorNumber: 3, error: errors[3] };\n    }\n    /* 4th criterion: 4th field is a valid e.p.-string? */\n    if (!/^(-|[abcdefgh][36])$/.test(tokens[3])) {\n        return { valid: false, errorNumber: 4, error: errors[4] };\n    }\n    /* 5th criterion: 3th field is a valid castle-string? */\n    if (!/^(KQ?k?q?|Qk?q?|kq?|q|-)$/.test(tokens[2])) {\n        return { valid: false, errorNumber: 5, error: errors[5] };\n    }\n    /* 6th criterion: 2nd field is \"w\" (white) or \"b\" (black)? */\n    if (!/^(w|b)$/.test(tokens[1])) {\n        return { valid: false, errorNumber: 6, error: errors[6] };\n    }\n    /* 7th criterion: 1st field contains 8 rows? */\n    const rows = tokens[0].split('/');\n    if (rows.length !== 8) {\n        return { valid: false, errorNumber: 7, error: errors[7] };\n    }\n    /* 8th criterion: every row is valid? */\n    for (let i = 0; i < rows.length; i++) {\n        /* check for right sum of fields AND not two numbers in succession */\n        let sumFields = 0;\n        let previousWasNumber = false;\n        for (let k = 0; k < rows[i].length; k++) {\n            if (isDigit(rows[i][k])) {\n                if (previousWasNumber) {\n                    return { valid: false, errorNumber: 8, error: errors[8] };\n                }\n                sumFields += parseInt(rows[i][k], 10);\n                previousWasNumber = true;\n            }\n            else {\n                if (!/^[prnbqkPRNBQK]$/.test(rows[i][k])) {\n                    return { valid: false, errorNumber: 9, error: errors[9] };\n                }\n                sumFields += 1;\n                previousWasNumber = false;\n            }\n        }\n        if (sumFields !== 8) {\n            return { valid: false, errorNumber: 10, error: errors[10] };\n        }\n    }\n    if ((tokens[3][1] == '3' && tokens[1] == 'w') ||\n        (tokens[3][1] == '6' && tokens[1] == 'b')) {\n        return { valid: false, errorNumber: 11, error: errors[11] };\n    }\n    /* everything's okay! */\n    return { valid: true, errorNumber: 0, error: errors[0] };\n}\nexports.validateFen = validateFen;\n/* this function is used to uniquely identify ambiguous moves */\nfunction getDisambiguator(move, moves) {\n    const from = move.from;\n    const to = move.to;\n    const piece = move.piece;\n    let ambiguities = 0;\n    let sameRank = 0;\n    let sameFile = 0;\n    for (let i = 0, len = moves.length; i < len; i++) {\n        const ambigFrom = moves[i].from;\n        const ambigTo = moves[i].to;\n        const ambigPiece = moves[i].piece;\n        /* if a move of the same piece type ends on the same to square, we'll\n         * need to add a disambiguator to the algebraic notation\n         */\n        if (piece === ambigPiece && from !== ambigFrom && to === ambigTo) {\n            ambiguities++;\n            if (rank(from) === rank(ambigFrom)) {\n                sameRank++;\n            }\n            if (file(from) === file(ambigFrom)) {\n                sameFile++;\n            }\n        }\n    }\n    if (ambiguities > 0) {\n        /* if there exists a similar moving piece on the same rank and file\n           as the move in question, use the square as the disambiguator\n        */\n        if (sameRank > 0 && sameFile > 0) {\n            return algebraic(from);\n        }\n        else if (sameFile > 0) {\n            /* if the moving piece rests on the same file, use the rank symbol\n               as the disambiguator\n             */\n            return algebraic(from).charAt(1);\n        }\n        else {\n            /* else use the file symbol */\n            return algebraic(from).charAt(0);\n        }\n    }\n    return '';\n}\nfunction addMove(moves, color, from, to, piece, captured = undefined, flags = BITS.NORMAL) {\n    const r = rank(to);\n    if (piece === exports.PAWN && (r === RANK_1 || r === RANK_8)) {\n        for (let i = 0; i < PROMOTIONS.length; i++) {\n            const promotion = PROMOTIONS[i];\n            moves.push({\n                color,\n                from,\n                to,\n                piece,\n                captured,\n                promotion,\n                flags: flags | BITS.PROMOTION,\n            });\n        }\n    }\n    else {\n        moves.push({\n            color,\n            from,\n            to,\n            piece,\n            captured,\n            promotion: undefined,\n            flags,\n        });\n    }\n}\nfunction inferPieceType(san) {\n    let pieceType = san.charAt(0);\n    if (pieceType >= 'a' && pieceType <= 'h') {\n        const matches = san.match(/[a-h]\\d.*[a-h]\\d/);\n        if (matches) {\n            return undefined;\n        }\n        return exports.PAWN;\n    }\n    pieceType = pieceType.toLowerCase();\n    if (pieceType === 'o') {\n        return exports.KING;\n    }\n    return pieceType;\n}\n// parses all of the decorators out of a SAN string\nfunction strippedSan(move) {\n    return move.replace(/=/, '').replace(/[+#]?[?!]*$/, '');\n}\nclass Chess {\n    constructor(fen = exports.DEFAULT_POSITION) {\n        this._board = new Array(128);\n        this._turn = exports.WHITE;\n        this._header = {};\n        this._kings = { w: EMPTY, b: EMPTY };\n        this._epSquare = -1;\n        this._halfMoves = 0;\n        this._moveNumber = 0;\n        this._history = [];\n        this._comments = {};\n        this._castling = { w: 0, b: 0 };\n        this.load(fen);\n    }\n    clear(keepHeaders = false) {\n        this._board = new Array(128);\n        this._kings = { w: EMPTY, b: EMPTY };\n        this._turn = exports.WHITE;\n        this._castling = { w: 0, b: 0 };\n        this._epSquare = EMPTY;\n        this._halfMoves = 0;\n        this._moveNumber = 1;\n        this._history = [];\n        this._comments = {};\n        this._header = keepHeaders ? this._header : {};\n        this._updateSetup(this.fen());\n    }\n    load(fen, keepHeaders = false) {\n        const tokens = fen.split(/\\s+/);\n        const position = tokens[0];\n        let square = 0;\n        if (!validateFen(fen).valid) {\n            return false;\n        }\n        this.clear(keepHeaders);\n        for (let i = 0; i < position.length; i++) {\n            const piece = position.charAt(i);\n            if (piece === '/') {\n                square += 8;\n            }\n            else if (isDigit(piece)) {\n                square += parseInt(piece, 10);\n            }\n            else {\n                const color = piece < 'a' ? exports.WHITE : exports.BLACK;\n                this.put({ type: piece.toLowerCase(), color }, algebraic(square));\n                square++;\n            }\n        }\n        this._turn = tokens[1];\n        if (tokens[2].indexOf('K') > -1) {\n            this._castling.w |= BITS.KSIDE_CASTLE;\n        }\n        if (tokens[2].indexOf('Q') > -1) {\n            this._castling.w |= BITS.QSIDE_CASTLE;\n        }\n        if (tokens[2].indexOf('k') > -1) {\n            this._castling.b |= BITS.KSIDE_CASTLE;\n        }\n        if (tokens[2].indexOf('q') > -1) {\n            this._castling.b |= BITS.QSIDE_CASTLE;\n        }\n        this._epSquare = tokens[3] === '-' ? EMPTY : Ox88[tokens[3]];\n        this._halfMoves = parseInt(tokens[4], 10);\n        this._moveNumber = parseInt(tokens[5], 10);\n        this._updateSetup(this.fen());\n        return true;\n    }\n    fen() {\n        let empty = 0;\n        let fen = '';\n        for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n            if (this._board[i]) {\n                if (empty > 0) {\n                    fen += empty;\n                    empty = 0;\n                }\n                const { color, type: piece } = this._board[i];\n                fen += color === exports.WHITE ? piece.toUpperCase() : piece.toLowerCase();\n            }\n            else {\n                empty++;\n            }\n            if ((i + 1) & 0x88) {\n                if (empty > 0) {\n                    fen += empty;\n                }\n                if (i !== Ox88.h1) {\n                    fen += '/';\n                }\n                empty = 0;\n                i += 8;\n            }\n        }\n        let cflags = '';\n        if (this._castling[exports.WHITE] & BITS.KSIDE_CASTLE) {\n            cflags += 'K';\n        }\n        if (this._castling[exports.WHITE] & BITS.QSIDE_CASTLE) {\n            cflags += 'Q';\n        }\n        if (this._castling[exports.BLACK] & BITS.KSIDE_CASTLE) {\n            cflags += 'k';\n        }\n        if (this._castling[exports.BLACK] & BITS.QSIDE_CASTLE) {\n            cflags += 'q';\n        }\n        /* do we have an empty castling flag? */\n        cflags = cflags || '-';\n        const epflags = this._epSquare === EMPTY ? '-' : algebraic(this._epSquare);\n        return [\n            fen,\n            this._turn,\n            cflags,\n            epflags,\n            this._halfMoves,\n            this._moveNumber,\n        ].join(' ');\n    }\n    /* Called when the initial board setup is changed with put() or remove().\n     * modifies the SetUp and FEN properties of the header object.  if the FEN\n     * is equal to the default position, the SetUp and FEN are deleted the setup\n     * is only updated if history.length is zero, ie moves haven't been  made.\n     */\n    _updateSetup(fen) {\n        if (this._history.length > 0)\n            return;\n        if (fen !== exports.DEFAULT_POSITION) {\n            this._header['SetUp'] = '1';\n            this._header['FEN'] = fen;\n        }\n        else {\n            delete this._header['SetUp'];\n            delete this._header['FEN'];\n        }\n    }\n    reset() {\n        this.load(exports.DEFAULT_POSITION);\n    }\n    get(square) {\n        return this._board[Ox88[square]] || false;\n    }\n    put({ type, color }, square) {\n        /* check for piece */\n        if (SYMBOLS.indexOf(type.toLowerCase()) === -1) {\n            return false;\n        }\n        /* check for valid square */\n        if (!(square in Ox88)) {\n            return false;\n        }\n        const sq = Ox88[square];\n        /* don't let the user place more than one king */\n        if (type == exports.KING &&\n            !(this._kings[color] == EMPTY || this._kings[color] == sq)) {\n            return false;\n        }\n        this._board[sq] = { type: type, color: color };\n        if (type === exports.KING) {\n            this._kings[color] = sq;\n        }\n        this._updateSetup(this.fen());\n        return true;\n    }\n    remove(square) {\n        const piece = this.get(square);\n        delete this._board[Ox88[square]];\n        if (piece && piece.type === exports.KING) {\n            this._kings[piece.color] = EMPTY;\n        }\n        this._updateSetup(this.fen());\n        return piece;\n    }\n    _attacked(color, square) {\n        for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n            /* did we run off the end of the board */\n            if (i & 0x88) {\n                i += 7;\n                continue;\n            }\n            /* if empty square or wrong color */\n            if (this._board[i] === undefined || this._board[i].color !== color) {\n                continue;\n            }\n            const piece = this._board[i];\n            const difference = i - square;\n            const index = difference + 119;\n            if (ATTACKS[index] & PIECE_MASKS[piece.type]) {\n                if (piece.type === exports.PAWN) {\n                    if (difference > 0) {\n                        if (piece.color === exports.WHITE)\n                            return true;\n                    }\n                    else {\n                        if (piece.color === exports.BLACK)\n                            return true;\n                    }\n                    continue;\n                }\n                /* if the piece is a knight or a king */\n                if (piece.type === 'n' || piece.type === 'k')\n                    return true;\n                const offset = RAYS[index];\n                let j = i + offset;\n                let blocked = false;\n                while (j !== square) {\n                    if (this._board[j] != null) {\n                        blocked = true;\n                        break;\n                    }\n                    j += offset;\n                }\n                if (!blocked)\n                    return true;\n            }\n        }\n        return false;\n    }\n    _isKingAttacked(color) {\n        return this._attacked(swapColor(color), this._kings[color]);\n    }\n    isCheck() {\n        return this._isKingAttacked(this._turn);\n    }\n    inCheck() {\n        return this.isCheck();\n    }\n    isCheckmate() {\n        return this.isCheck() && this._moves().length === 0;\n    }\n    isStalemate() {\n        return !this.isCheck() && this._moves().length === 0;\n    }\n    isInsufficientMaterial() {\n        // k.b. vs k.b. (of opposite colors) with mate in 1:\n        // 8/8/8/8/1b6/8/B1k5/K7 b - - 0 1\n        //\n        // k.b. vs k.n. with mate in 1:\n        // 8/8/8/8/1n6/8/B7/K1k5 b - - 2 1\n        const pieces = {\n            b: 0,\n            n: 0,\n            r: 0,\n            q: 0,\n            k: 0,\n            p: 0,\n        };\n        const bishops = [];\n        let numPieces = 0;\n        let squareColor = 0;\n        for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n            squareColor = (squareColor + 1) % 2;\n            if (i & 0x88) {\n                i += 7;\n                continue;\n            }\n            const piece = this._board[i];\n            if (piece) {\n                pieces[piece.type] = piece.type in pieces ? pieces[piece.type] + 1 : 1;\n                if (piece.type === exports.BISHOP) {\n                    bishops.push(squareColor);\n                }\n                numPieces++;\n            }\n        }\n        // k vs. k\n        if (numPieces === 2) {\n            return true;\n        }\n        else if (\n        // k vs. kn .... or .... k vs. kb\n        numPieces === 3 &&\n            (pieces[exports.BISHOP] === 1 || pieces[exports.KNIGHT] === 1)) {\n            return true;\n        }\n        else if (numPieces === pieces[exports.BISHOP] + 2) {\n            // kb vs. kb where any number of bishops are all on the same color\n            let sum = 0;\n            const len = bishops.length;\n            for (let i = 0; i < len; i++) {\n                sum += bishops[i];\n            }\n            if (sum === 0 || sum === len) {\n                return true;\n            }\n        }\n        return false;\n    }\n    isThreefoldRepetition() {\n        /* TODO: while this function is fine for casual use, a better\n          * implementation would use a Zobrist key (instead of FEN). the\n          * Zobrist key would be maintained in the make_move/undo_move\n          functions,\n          * avoiding the costly that we do below.\n          */\n        const moves = [];\n        const positions = {};\n        let repetition = false;\n        while (true) {\n            const move = this._undoMove();\n            if (!move)\n                break;\n            moves.push(move);\n        }\n        while (true) {\n            /* remove the last two fields in the FEN string, they're not needed\n             * when checking for draw by rep */\n            const fen = this.fen().split(' ').slice(0, 4).join(' ');\n            /* has the position occurred three or move times */\n            positions[fen] = fen in positions ? positions[fen] + 1 : 1;\n            if (positions[fen] >= 3) {\n                repetition = true;\n            }\n            const move = moves.pop();\n            if (!move) {\n                break;\n            }\n            else {\n                this._makeMove(move);\n            }\n        }\n        return repetition;\n    }\n    isDraw() {\n        return (this._halfMoves >= 100 || // 50 moves per side = 100 half moves\n            this.isStalemate() ||\n            this.isInsufficientMaterial() ||\n            this.isThreefoldRepetition());\n    }\n    isGameOver() {\n        return this.isCheckmate() || this.isStalemate() || this.isDraw();\n    }\n    moves({ verbose = false, square = undefined, } = {}) {\n        const moves = this._moves({ square });\n        if (verbose) {\n            return moves.map((move) => this._makePretty(move));\n        }\n        else {\n            return moves.map((move) => this._moveToSan(move, moves));\n        }\n    }\n    _moves({ legal = true, piece = undefined, square = undefined, } = {}) {\n        var _a;\n        const forSquare = square ? square.toLowerCase() : undefined;\n        const forPiece = piece === null || piece === void 0 ? void 0 : piece.toLowerCase();\n        const moves = [];\n        const us = this._turn;\n        const them = swapColor(us);\n        let firstSquare = Ox88.a8;\n        let lastSquare = Ox88.h1;\n        let singleSquare = false;\n        /* are we generating moves for a single square? */\n        if (forSquare) {\n            // illegal square, return empty moves\n            if (!(forSquare in Ox88)) {\n                return [];\n            }\n            else {\n                firstSquare = lastSquare = Ox88[forSquare];\n                singleSquare = true;\n            }\n        }\n        for (let from = firstSquare; from <= lastSquare; from++) {\n            /* did we run off the end of the board */\n            if (from & 0x88) {\n                from += 7;\n                continue;\n            }\n            // empty square or opponent, skip\n            if (!this._board[from] || this._board[from].color === them) {\n                continue;\n            }\n            const { type } = this._board[from];\n            let to;\n            if (type === exports.PAWN) {\n                if (forPiece && forPiece !== type)\n                    continue;\n                /* single square, non-capturing */\n                to = from + PAWN_OFFSETS[us][0];\n                if (!this._board[to]) {\n                    addMove(moves, us, from, to, exports.PAWN);\n                    /* double square */\n                    to = from + PAWN_OFFSETS[us][1];\n                    if (SECOND_RANK[us] === rank(from) && !this._board[to]) {\n                        addMove(moves, us, from, to, exports.PAWN, undefined, BITS.BIG_PAWN);\n                    }\n                }\n                /* pawn captures */\n                for (let j = 2; j < 4; j++) {\n                    to = from + PAWN_OFFSETS[us][j];\n                    if (to & 0x88)\n                        continue;\n                    if (((_a = this._board[to]) === null || _a === void 0 ? void 0 : _a.color) === them) {\n                        addMove(moves, us, from, to, exports.PAWN, this._board[to].type, BITS.CAPTURE);\n                    }\n                    else if (to === this._epSquare) {\n                        addMove(moves, us, from, to, exports.PAWN, exports.PAWN, BITS.EP_CAPTURE);\n                    }\n                }\n            }\n            else {\n                if (forPiece && forPiece !== type)\n                    continue;\n                for (let j = 0, len = PIECE_OFFSETS[type].length; j < len; j++) {\n                    const offset = PIECE_OFFSETS[type][j];\n                    to = from;\n                    while (true) {\n                        to += offset;\n                        if (to & 0x88)\n                            break;\n                        if (!this._board[to]) {\n                            addMove(moves, us, from, to, type);\n                        }\n                        else {\n                            // own color, stop loop\n                            if (this._board[to].color === us)\n                                break;\n                            addMove(moves, us, from, to, type, this._board[to].type, BITS.CAPTURE);\n                            break;\n                        }\n                        /* break, if knight or king */\n                        if (type === exports.KNIGHT || type === exports.KING)\n                            break;\n                    }\n                }\n            }\n        }\n        /* check for castling if:\n         * a) we're generating all moves, or\n         * b) we're doing single square move generation on the king's square\n         */\n        if (forPiece === undefined || forPiece === exports.KING) {\n            if (!singleSquare || lastSquare === this._kings[us]) {\n                /* king-side castling */\n                if (this._castling[us] & BITS.KSIDE_CASTLE) {\n                    const castlingFrom = this._kings[us];\n                    const castlingTo = castlingFrom + 2;\n                    if (!this._board[castlingFrom + 1] &&\n                        !this._board[castlingTo] &&\n                        !this._attacked(them, this._kings[us]) &&\n                        !this._attacked(them, castlingFrom + 1) &&\n                        !this._attacked(them, castlingTo)) {\n                        addMove(moves, us, this._kings[us], castlingTo, exports.KING, undefined, BITS.KSIDE_CASTLE);\n                    }\n                }\n                /* queen-side castling */\n                if (this._castling[us] & BITS.QSIDE_CASTLE) {\n                    const castlingFrom = this._kings[us];\n                    const castlingTo = castlingFrom - 2;\n                    if (!this._board[castlingFrom - 1] &&\n                        !this._board[castlingFrom - 2] &&\n                        !this._board[castlingFrom - 3] &&\n                        !this._attacked(them, this._kings[us]) &&\n                        !this._attacked(them, castlingFrom - 1) &&\n                        !this._attacked(them, castlingTo)) {\n                        addMove(moves, us, this._kings[us], castlingTo, exports.KING, undefined, BITS.QSIDE_CASTLE);\n                    }\n                }\n            }\n        }\n        /* return all pseudo-legal moves (this includes moves that allow the king\n         * to be captured) */\n        if (!legal) {\n            return moves;\n        }\n        /* filter out illegal moves */\n        const legalMoves = [];\n        for (let i = 0, len = moves.length; i < len; i++) {\n            this._makeMove(moves[i]);\n            if (!this._isKingAttacked(us)) {\n                legalMoves.push(moves[i]);\n            }\n            this._undoMove();\n        }\n        return legalMoves;\n    }\n    move(move, { sloppy = false } = {}) {\n        /* The move function can be called with in the following parameters:\n            *\n            * .move('Nxb7')      <- where 'move' is a case-sensitive SAN string\n            *\n            * .move({ from: 'h7', <- where the 'move' is a move object\n            (additional\n            *         to :'h8',      fields are ignored)\n            *         promotion: 'q',\n            *      })\n            */\n        // sloppy parser allows the move parser to work around over disambiguation\n        // bugs in Fritz and Chessbase\n        let moveObj = null;\n        if (typeof move === 'string') {\n            moveObj = this._moveFromSan(move, sloppy);\n        }\n        else if (typeof move === 'object') {\n            const moves = this._moves();\n            /* convert the pretty move object to an ugly move object */\n            for (let i = 0, len = moves.length; i < len; i++) {\n                if (move.from === algebraic(moves[i].from) &&\n                    move.to === algebraic(moves[i].to) &&\n                    (!('promotion' in moves[i]) || move.promotion === moves[i].promotion)) {\n                    moveObj = moves[i];\n                    break;\n                }\n            }\n        }\n        /* failed to find move */\n        if (!moveObj) {\n            return null;\n        }\n        /* need to make a copy of move because we can't generate SAN after\n           the move is made */\n        const prettyMove = this._makePretty(moveObj);\n        this._makeMove(moveObj);\n        return prettyMove;\n    }\n    _push(move) {\n        this._history.push({\n            move,\n            kings: { b: this._kings.b, w: this._kings.w },\n            turn: this._turn,\n            castling: { b: this._castling.b, w: this._castling.w },\n            epSquare: this._epSquare,\n            halfMoves: this._halfMoves,\n            moveNumber: this._moveNumber,\n        });\n    }\n    _makeMove(move) {\n        const us = this._turn;\n        const them = swapColor(us);\n        this._push(move);\n        this._board[move.to] = this._board[move.from];\n        delete this._board[move.from];\n        /* if ep capture, remove the captured pawn */\n        if (move.flags & BITS.EP_CAPTURE) {\n            if (this._turn === exports.BLACK) {\n                delete this._board[move.to - 16];\n            }\n            else {\n                delete this._board[move.to + 16];\n            }\n        }\n        /* if pawn promotion, replace with new piece */\n        if (move.promotion) {\n            this._board[move.to] = { type: move.promotion, color: us };\n        }\n        /* if we moved the king */\n        if (this._board[move.to].type === exports.KING) {\n            this._kings[us] = move.to;\n            /* if we castled, move the rook next to the king */\n            if (move.flags & BITS.KSIDE_CASTLE) {\n                const castlingTo = move.to - 1;\n                const castlingFrom = move.to + 1;\n                this._board[castlingTo] = this._board[castlingFrom];\n                delete this._board[castlingFrom];\n            }\n            else if (move.flags & BITS.QSIDE_CASTLE) {\n                const castlingTo = move.to + 1;\n                const castlingFrom = move.to - 2;\n                this._board[castlingTo] = this._board[castlingFrom];\n                delete this._board[castlingFrom];\n            }\n            /* turn off castling */\n            this._castling[us] = 0;\n        }\n        /* turn off castling if we move a rook */\n        if (this._castling[us]) {\n            for (let i = 0, len = ROOKS[us].length; i < len; i++) {\n                if (move.from === ROOKS[us][i].square &&\n                    this._castling[us] & ROOKS[us][i].flag) {\n                    this._castling[us] ^= ROOKS[us][i].flag;\n                    break;\n                }\n            }\n        }\n        /* turn off castling if we capture a rook */\n        if (this._castling[them]) {\n            for (let i = 0, len = ROOKS[them].length; i < len; i++) {\n                if (move.to === ROOKS[them][i].square &&\n                    this._castling[them] & ROOKS[them][i].flag) {\n                    this._castling[them] ^= ROOKS[them][i].flag;\n                    break;\n                }\n            }\n        }\n        /* if big pawn move, update the en passant square */\n        if (move.flags & BITS.BIG_PAWN) {\n            if (us === exports.BLACK) {\n                this._epSquare = move.to - 16;\n            }\n            else {\n                this._epSquare = move.to + 16;\n            }\n        }\n        else {\n            this._epSquare = EMPTY;\n        }\n        /* reset the 50 move counter if a pawn is moved or a piece is captured */\n        if (move.piece === exports.PAWN) {\n            this._halfMoves = 0;\n        }\n        else if (move.flags & (BITS.CAPTURE | BITS.EP_CAPTURE)) {\n            this._halfMoves = 0;\n        }\n        else {\n            this._halfMoves++;\n        }\n        if (us === exports.BLACK) {\n            this._moveNumber++;\n        }\n        this._turn = them;\n    }\n    undo() {\n        const move = this._undoMove();\n        return move ? this._makePretty(move) : null;\n    }\n    _undoMove() {\n        const old = this._history.pop();\n        if (old === undefined) {\n            return null;\n        }\n        const move = old.move;\n        this._kings = old.kings;\n        this._turn = old.turn;\n        this._castling = old.castling;\n        this._epSquare = old.epSquare;\n        this._halfMoves = old.halfMoves;\n        this._moveNumber = old.moveNumber;\n        const us = this._turn;\n        const them = swapColor(us);\n        this._board[move.from] = this._board[move.to];\n        this._board[move.from].type = move.piece; // to undo any promotions\n        delete this._board[move.to];\n        if (move.captured) {\n            if (move.flags & BITS.EP_CAPTURE) {\n                // en passant capture\n                let index;\n                if (us === exports.BLACK) {\n                    index = move.to - 16;\n                }\n                else {\n                    index = move.to + 16;\n                }\n                this._board[index] = { type: exports.PAWN, color: them };\n            }\n            else {\n                // regular capture\n                this._board[move.to] = { type: move.captured, color: them };\n            }\n        }\n        if (move.flags & (BITS.KSIDE_CASTLE | BITS.QSIDE_CASTLE)) {\n            let castlingTo, castlingFrom;\n            if (move.flags & BITS.KSIDE_CASTLE) {\n                castlingTo = move.to + 1;\n                castlingFrom = move.to - 1;\n            }\n            else {\n                castlingTo = move.to - 2;\n                castlingFrom = move.to + 1;\n            }\n            this._board[castlingTo] = this._board[castlingFrom];\n            delete this._board[castlingFrom];\n        }\n        return move;\n    }\n    pgn({ newline = '\\n', maxWidth = 0, } = {}) {\n        /* using the specification from http://www.chessclub.com/help/PGN-spec\n         * example for html usage: .pgn({ max_width: 72, newline_char: \"<br />\" })\n         */\n        const result = [];\n        let headerExists = false;\n        /* add the PGN header information */\n        for (const i in this._header) {\n            /* TODO: order of enumerated properties in header object is not\n             * guaranteed, see ECMA-262 spec (section 12.6.4)\n             */\n            result.push('[' + i + ' \"' + this._header[i] + '\"]' + newline);\n            headerExists = true;\n        }\n        if (headerExists && this._history.length) {\n            result.push(newline);\n        }\n        const appendComment = (moveString) => {\n            const comment = this._comments[this.fen()];\n            if (typeof comment !== 'undefined') {\n                const delimiter = moveString.length > 0 ? ' ' : '';\n                moveString = `${moveString}${delimiter}{${comment}}`;\n            }\n            return moveString;\n        };\n        /* pop all of history onto reversed_history */\n        const reversedHistory = [];\n        while (this._history.length > 0) {\n            reversedHistory.push(this._undoMove());\n        }\n        const moves = [];\n        let moveString = '';\n        /* special case of a commented starting position with no moves */\n        if (reversedHistory.length === 0) {\n            moves.push(appendComment(''));\n        }\n        /* build the list of moves.  a move_string looks like: \"3. e3 e6\" */\n        while (reversedHistory.length > 0) {\n            moveString = appendComment(moveString);\n            const move = reversedHistory.pop();\n            // make TypeScript stop complaining about move being undefined\n            if (!move) {\n                break;\n            }\n            /* if the position started with black to move, start PGN with #. ... */\n            if (!this._history.length && move.color === 'b') {\n                const prefix = `${this._moveNumber}. ...`;\n                /* is there a comment preceding the first move? */\n                moveString = moveString ? `${moveString} ${prefix}` : prefix;\n            }\n            else if (move.color === 'w') {\n                /* store the previous generated move_string if we have one */\n                if (moveString.length) {\n                    moves.push(moveString);\n                }\n                moveString = this._moveNumber + '.';\n            }\n            moveString =\n                moveString + ' ' + this._moveToSan(move, this._moves({ legal: true }));\n            this._makeMove(move);\n        }\n        /* are there any other leftover moves? */\n        if (moveString.length) {\n            moves.push(appendComment(moveString));\n        }\n        /* is there a result? */\n        if (typeof this._header.Result !== 'undefined') {\n            moves.push(this._header.Result);\n        }\n        /* history should be back to what it was before we started generating PGN,\n         * so join together moves\n         */\n        if (maxWidth === 0) {\n            return result.join('') + moves.join(' ');\n        }\n        // JAH: huh?\n        const strip = function () {\n            if (result.length > 0 && result[result.length - 1] === ' ') {\n                result.pop();\n                return true;\n            }\n            return false;\n        };\n        /* NB: this does not preserve comment whitespace. */\n        const wrapComment = function (width, move) {\n            for (const token of move.split(' ')) {\n                if (!token) {\n                    continue;\n                }\n                if (width + token.length > maxWidth) {\n                    while (strip()) {\n                        width--;\n                    }\n                    result.push(newline);\n                    width = 0;\n                }\n                result.push(token);\n                width += token.length;\n                result.push(' ');\n                width++;\n            }\n            if (strip()) {\n                width--;\n            }\n            return width;\n        };\n        /* wrap the PGN output at max_width */\n        let currentWidth = 0;\n        for (let i = 0; i < moves.length; i++) {\n            if (currentWidth + moves[i].length > maxWidth) {\n                if (moves[i].includes('{')) {\n                    currentWidth = wrapComment(currentWidth, moves[i]);\n                    continue;\n                }\n            }\n            /* if the current move will push past max_width */\n            if (currentWidth + moves[i].length > maxWidth && i !== 0) {\n                /* don't end the line with whitespace */\n                if (result[result.length - 1] === ' ') {\n                    result.pop();\n                }\n                result.push(newline);\n                currentWidth = 0;\n            }\n            else if (i !== 0) {\n                result.push(' ');\n                currentWidth++;\n            }\n            result.push(moves[i]);\n            currentWidth += moves[i].length;\n        }\n        return result.join('');\n    }\n    header(...args) {\n        for (let i = 0; i < args.length; i += 2) {\n            if (typeof args[i] === 'string' && typeof args[i + 1] === 'string') {\n                this._header[args[i]] = args[i + 1];\n            }\n        }\n        return this._header;\n    }\n    loadPgn(pgn, { sloppy = false, newlineChar = '\\r?\\n', } = {}) {\n        // option sloppy=true\n        // allow the user to specify the sloppy move parser to work around over\n        // disambiguation bugs in Fritz and Chessbase\n        function mask(str) {\n            return str.replace(/\\\\/g, '\\\\');\n        }\n        function parsePgnHeader(header) {\n            const headerObj = {};\n            const headers = header.split(new RegExp(mask(newlineChar)));\n            let key = '';\n            let value = '';\n            for (let i = 0; i < headers.length; i++) {\n                const regex = /^\\s*\\[([A-Za-z]+)\\s*\"(.*)\"\\s*\\]\\s*$/;\n                key = headers[i].replace(regex, '$1');\n                value = headers[i].replace(regex, '$2');\n                if (key.trim().length > 0) {\n                    headerObj[key] = value;\n                }\n            }\n            return headerObj;\n        }\n        // strip whitespace from head/tail of PGN block\n        pgn = pgn.trim();\n        // RegExp to split header. Takes advantage of the fact that header and movetext\n        // will always have a blank line between them (ie, two newline_char's).\n        // With default newline_char, will equal: /^(\\[((?:\\r?\\n)|.)*\\])(?:\\s*\\r?\\n){2}/\n        const headerRegex = new RegExp('^(\\\\[((?:' +\n            mask(newlineChar) +\n            ')|.)*\\\\])' +\n            '(?:\\\\s*' +\n            mask(newlineChar) +\n            '){2}');\n        // If no header given, begin with moves.\n        const headerRegexResults = headerRegex.exec(pgn);\n        const headerString = headerRegexResults\n            ? headerRegexResults.length >= 2\n                ? headerRegexResults[1]\n                : ''\n            : '';\n        // Put the board in the starting position\n        this.reset();\n        /* parse PGN header */\n        const headers = parsePgnHeader(headerString);\n        let fen = '';\n        for (const key in headers) {\n            // check to see user is including fen (possibly with wrong tag case)\n            if (key.toLowerCase() === 'fen') {\n                fen = headers[key];\n            }\n            this.header(key, headers[key]);\n        }\n        /* sloppy parser should attempt to load a fen tag, even if it's\n         * the wrong case and doesn't include a corresponding [SetUp \"1\"] tag */\n        if (sloppy) {\n            if (fen) {\n                if (!this.load(fen, true)) {\n                    return false;\n                }\n            }\n        }\n        else {\n            /* strict parser - load the starting position indicated by [Setup '1']\n             * and [FEN position] */\n            if (headers['SetUp'] === '1') {\n                if (!('FEN' in headers && this.load(headers['FEN'], true))) {\n                    // second argument to load: don't clear the headers\n                    return false;\n                }\n            }\n        }\n        /* NB: the regexes below that delete move numbers, recursive\n         * annotations, and numeric annotation glyphs may also match\n         * text in comments. To prevent this, we transform comments\n         * by hex-encoding them in place and decoding them again after\n         * the other tokens have been deleted.\n         *\n         * While the spec states that PGN files should be ASCII encoded,\n         * we use {en,de}codeURIComponent here to support arbitrary UTF8\n         * as a convenience for modern users */\n        function toHex(s) {\n            return Array.from(s)\n                .map(function (c) {\n                /* encodeURI doesn't transform most ASCII characters,\n                 * so we handle these ourselves */\n                return c.charCodeAt(0) < 128\n                    ? c.charCodeAt(0).toString(16)\n                    : encodeURIComponent(c).replace(/%/g, '').toLowerCase();\n            })\n                .join('');\n        }\n        function fromHex(s) {\n            return s.length == 0\n                ? ''\n                : decodeURIComponent('%' + (s.match(/.{1,2}/g) || []).join('%'));\n        }\n        const encodeComment = function (s) {\n            s = s.replace(new RegExp(mask(newlineChar), 'g'), ' ');\n            return `{${toHex(s.slice(1, s.length - 1))}}`;\n        };\n        const decodeComment = function (s) {\n            if (s.startsWith('{') && s.endsWith('}')) {\n                return fromHex(s.slice(1, s.length - 1));\n            }\n        };\n        /* delete header to get the moves */\n        let ms = pgn\n            .replace(headerString, '')\n            .replace(\n        /* encode comments so they don't get deleted below */\n        new RegExp(`({[^}]*})+?|;([^${mask(newlineChar)}]*)`, 'g'), function (_match, bracket, semicolon) {\n            return bracket !== undefined\n                ? encodeComment(bracket)\n                : ' ' + encodeComment(`{${semicolon.slice(1)}}`);\n        })\n            .replace(new RegExp(mask(newlineChar), 'g'), ' ');\n        /* delete recursive annotation variations */\n        const ravRegex = /(\\([^()]+\\))+?/g;\n        while (ravRegex.test(ms)) {\n            ms = ms.replace(ravRegex, '');\n        }\n        /* delete move numbers */\n        ms = ms.replace(/\\d+\\.(\\.\\.)?/g, '');\n        /* delete ... indicating black to move */\n        ms = ms.replace(/\\.\\.\\./g, '');\n        /* delete numeric annotation glyphs */\n        ms = ms.replace(/\\$\\d+/g, '');\n        /* trim and get array of moves */\n        let moves = ms.trim().split(new RegExp(/\\s+/));\n        /* delete empty entries */\n        moves = moves.join(',').replace(/,,+/g, ',').split(',');\n        let result = '';\n        for (let halfMove = 0; halfMove < moves.length; halfMove++) {\n            const comment = decodeComment(moves[halfMove]);\n            if (comment !== undefined) {\n                this._comments[this.fen()] = comment;\n                continue;\n            }\n            const move = this._moveFromSan(moves[halfMove], sloppy);\n            /* invalid move */\n            if (move == null) {\n                /* was the move an end of game marker */\n                if (TERMINATION_MARKERS.indexOf(moves[halfMove]) > -1) {\n                    result = moves[halfMove];\n                }\n                else {\n                    return false;\n                }\n            }\n            else {\n                /* reset the end of game marker if making a valid move */\n                result = '';\n                this._makeMove(move);\n            }\n        }\n        /* Per section 8.2.6 of the PGN spec, the Result tag pair must match\n    * match the termination marker. Only do this when headers are\n            present,\n            * but the result tag is missing\n            */\n        if (result && Object.keys(this._header).length && !this._header['Result']) {\n            this.header('Result', result);\n        }\n        return true;\n    }\n    /* convert a move from 0x88 coordinates to Standard Algebraic Notation\n      * (SAN)\n      *\n      * @param {boolean} sloppy Use the sloppy SAN generator to work around\n      over\n      * disambiguation bugs in Fritz and Chessbase.  See below:\n      *\n      * r1bqkbnr/ppp2ppp/2n5/1B1pP3/4P3/8/PPPP2PP/RNBQK1NR b KQkq - 2 4\n      * 4. ... Nge7 is overly disambiguated because the knight on c6 is pinned\n      * 4. ... Ne7 is technically the valid SAN\n      */\n    _moveToSan(move, moves) {\n        let output = '';\n        if (move.flags & BITS.KSIDE_CASTLE) {\n            output = 'O-O';\n        }\n        else if (move.flags & BITS.QSIDE_CASTLE) {\n            output = 'O-O-O';\n        }\n        else {\n            if (move.piece !== exports.PAWN) {\n                const disambiguator = getDisambiguator(move, moves);\n                output += move.piece.toUpperCase() + disambiguator;\n            }\n            if (move.flags & (BITS.CAPTURE | BITS.EP_CAPTURE)) {\n                if (move.piece === exports.PAWN) {\n                    output += algebraic(move.from)[0];\n                }\n                output += 'x';\n            }\n            output += algebraic(move.to);\n            if (move.promotion) {\n                output += '=' + move.promotion.toUpperCase();\n            }\n        }\n        this._makeMove(move);\n        if (this.isCheck()) {\n            if (this.isCheckmate()) {\n                output += '#';\n            }\n            else {\n                output += '+';\n            }\n        }\n        this._undoMove();\n        return output;\n    }\n    // convert a move from Standard Algebraic Notation (SAN) to 0x88\n    // coordinates\n    _moveFromSan(move, sloppy = false) {\n        // strip off any move decorations: e.g Nf3+?! becomes Nf3\n        const cleanMove = strippedSan(move);\n        let pieceType = inferPieceType(cleanMove);\n        let moves = this._moves({ legal: true, piece: pieceType });\n        // strict parser\n        for (let i = 0, len = moves.length; i < len; i++) {\n            if (cleanMove === strippedSan(this._moveToSan(moves[i], moves))) {\n                return moves[i];\n            }\n        }\n        // strict parser failed and the sloppy parser wasn't used, return null\n        if (!sloppy) {\n            return null;\n        }\n        let piece = undefined;\n        let matches = undefined;\n        let from = undefined;\n        let to = undefined;\n        let promotion = undefined;\n        // The sloppy parser allows the user to parse non-standard chess\n        // notations. This parser is opt-in (by specifying the\n        // '{ sloppy: true }' setting) and is only run after the Standard\n        // Algebraic Notation (SAN) parser has failed.\n        //\n        // When running the sloppy parser, we'll run a regex to grab the piece,\n        // the to/from square, and an optional promotion piece. This regex will\n        // parse common non-standard notation like: Pe2-e4, Rc1c4, Qf3xf7,\n        // f7f8q, b1c3\n        // NOTE: Some positions and moves may be ambiguous when using the\n        // sloppy parser. For example, in this position:\n        // 6k1/8/8/B7/8/8/8/BN4K1 w - - 0 1, the move b1c3 may be interpreted\n        // as Nc3 or B1c3 (a disambiguated bishop move). In these cases, the\n        // sloppy parser will default to the most most basic interpretation\n        // (which is b1c3 parsing to Nc3).\n        // FIXME: these var's are hoisted into function scope, this will need\n        // to change when switching to const/let\n        let overlyDisambiguated = false;\n        matches = cleanMove.match(/([pnbrqkPNBRQK])?([a-h][1-8])x?-?([a-h][1-8])([qrbnQRBN])?/\n        //     piece         from              to       promotion\n        );\n        if (matches) {\n            piece = matches[1];\n            from = matches[2];\n            to = matches[3];\n            promotion = matches[4];\n            if (from.length == 1) {\n                overlyDisambiguated = true;\n            }\n        }\n        else {\n            // The [a-h]?[1-8]? portion of the regex below handles moves that may\n            // be overly disambiguated (e.g. Nge7 is unnecessary and non-standard\n            // when there is one legal knight move to e7). In this case, the value\n            // of 'from' variable will be a rank or file, not a square.\n            matches = cleanMove.match(/([pnbrqkPNBRQK])?([a-h]?[1-8]?)x?-?([a-h][1-8])([qrbnQRBN])?/);\n            if (matches) {\n                piece = matches[1];\n                from = matches[2];\n                to = matches[3];\n                promotion = matches[4];\n                if (from.length == 1) {\n                    overlyDisambiguated = true;\n                }\n            }\n        }\n        pieceType = inferPieceType(cleanMove);\n        moves = this._moves({\n            legal: true,\n            piece: piece ? piece : pieceType,\n        });\n        for (let i = 0, len = moves.length; i < len; i++) {\n            if (from && to) {\n                // hand-compare move properties with the results from our sloppy\n                // regex\n                if ((!piece || piece.toLowerCase() == moves[i].piece) &&\n                    Ox88[from] == moves[i].from &&\n                    Ox88[to] == moves[i].to &&\n                    (!promotion || promotion.toLowerCase() == moves[i].promotion)) {\n                    return moves[i];\n                }\n                else if (overlyDisambiguated) {\n                    // SPECIAL CASE: we parsed a move string that may have an\n                    // unneeded rank/file disambiguator (e.g. Nge7).  The 'from'\n                    // variable will\n                    const square = algebraic(moves[i].from);\n                    if ((!piece || piece.toLowerCase() == moves[i].piece) &&\n                        Ox88[to] == moves[i].to &&\n                        (from == square[0] || from == square[1]) &&\n                        (!promotion || promotion.toLowerCase() == moves[i].promotion)) {\n                        return moves[i];\n                    }\n                }\n            }\n        }\n        return null;\n    }\n    ascii() {\n        let s = '   +------------------------+\\n';\n        for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n            /* display the rank */\n            if (file(i) === 0) {\n                s += ' ' + '87654321'[rank(i)] + ' |';\n            }\n            if (this._board[i]) {\n                const piece = this._board[i].type;\n                const color = this._board[i].color;\n                const symbol = color === exports.WHITE ? piece.toUpperCase() : piece.toLowerCase();\n                s += ' ' + symbol + ' ';\n            }\n            else {\n                s += ' . ';\n            }\n            if ((i + 1) & 0x88) {\n                s += '|\\n';\n                i += 8;\n            }\n        }\n        s += '   +------------------------+\\n';\n        s += '     a  b  c  d  e  f  g  h';\n        return s;\n    }\n    perft(depth) {\n        const moves = this._moves({ legal: false });\n        let nodes = 0;\n        const color = this._turn;\n        for (let i = 0, len = moves.length; i < len; i++) {\n            this._makeMove(moves[i]);\n            if (!this._isKingAttacked(color)) {\n                if (depth - 1 > 0) {\n                    nodes += this.perft(depth - 1);\n                }\n                else {\n                    nodes++;\n                }\n            }\n            this._undoMove();\n        }\n        return nodes;\n    }\n    /* pretty = external move object */\n    _makePretty(uglyMove) {\n        const { color, piece, from, to, flags, captured, promotion } = uglyMove;\n        let prettyFlags = '';\n        for (const flag in BITS) {\n            if (BITS[flag] & flags) {\n                prettyFlags += FLAGS[flag];\n            }\n        }\n        const move = {\n            color,\n            piece,\n            from: algebraic(from),\n            to: algebraic(to),\n            san: this._moveToSan(uglyMove, this._moves({ legal: true })),\n            flags: prettyFlags,\n        };\n        if (captured) {\n            move.captured = captured;\n        }\n        if (promotion) {\n            move.promotion = promotion;\n        }\n        return move;\n    }\n    turn() {\n        return this._turn;\n    }\n    board() {\n        const output = [];\n        let row = [];\n        for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n            if (this._board[i] == null) {\n                row.push(null);\n            }\n            else {\n                row.push({\n                    square: algebraic(i),\n                    type: this._board[i].type,\n                    color: this._board[i].color,\n                });\n            }\n            if ((i + 1) & 0x88) {\n                output.push(row);\n                row = [];\n                i += 8;\n            }\n        }\n        return output;\n    }\n    squareColor(square) {\n        if (square in Ox88) {\n            const sq = Ox88[square];\n            return (rank(sq) + file(sq)) % 2 === 0 ? 'light' : 'dark';\n        }\n        return null;\n    }\n    history({ verbose = false } = {}) {\n        const reversedHistory = [];\n        const moveHistory = [];\n        while (this._history.length > 0) {\n            reversedHistory.push(this._undoMove());\n        }\n        while (true) {\n            const move = reversedHistory.pop();\n            if (!move) {\n                break;\n            }\n            if (verbose) {\n                moveHistory.push(this._makePretty(move));\n            }\n            else {\n                moveHistory.push(this._moveToSan(move, this._moves()));\n            }\n            this._makeMove(move);\n        }\n        return moveHistory;\n    }\n    _pruneComments() {\n        const reversedHistory = [];\n        const currentComments = {};\n        const copyComment = (fen) => {\n            if (fen in this._comments) {\n                currentComments[fen] = this._comments[fen];\n            }\n        };\n        while (this._history.length > 0) {\n            reversedHistory.push(this._undoMove());\n        }\n        copyComment(this.fen());\n        while (true) {\n            const move = reversedHistory.pop();\n            if (!move) {\n                break;\n            }\n            this._makeMove(move);\n            copyComment(this.fen());\n        }\n        this._comments = currentComments;\n    }\n    getComment() {\n        return this._comments[this.fen()];\n    }\n    setComment(comment) {\n        this._comments[this.fen()] = comment.replace('{', '[').replace('}', ']');\n    }\n    deleteComment() {\n        const comment = this._comments[this.fen()];\n        delete this._comments[this.fen()];\n        return comment;\n    }\n    getComments() {\n        this._pruneComments();\n        return Object.keys(this._comments).map((fen) => {\n            return { fen: fen, comment: this._comments[fen] };\n        });\n    }\n    deleteComments() {\n        this._pruneComments();\n        return Object.keys(this._comments).map((fen) => {\n            const comment = this._comments[fen];\n            delete this._comments[fen];\n            return { fen: fen, comment: comment };\n        });\n    }\n}\nexports.Chess = Chess;\n//   return {\n//     /***************************************************************************\n//      * PUBLIC CONSTANTS (is there a better way to do this?)\n//      **************************************************************************/\n//     SQUARES: (function () {\n//       /* from the ECMA-262 spec (section 12.6.4):\n//        * \"The mechanics of enumerating the properties ... is\n//        * implementation dependent\"\n//        * so: for (var sq in SQUARES) { keys.push(sq); } might not be\n//        * ordered correctly\n//        */\n//       var keys = []\n//       for (var i = SQUARES.a8; i <= SQUARES.h1; i++) {\n//         if (i & 0x88) {\n//           i += 7\n//           continue\n//         }\n//         keys.push(algebraic(i))\n//       }\n//       return keys\n//     })(),\n//     FLAGS: FLAGS,\n// }\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}